<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
<!--
body
{
    margin-left:  30px;
    margin-right: 30px;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #1F37B5;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}
h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
	border-radius: 10px;
	padding: 5px;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #9ed8ff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #C0F0E0;
    font-size: 100%;
	width: 100%;
	border-radius: 5px;
	padding: 5px;
}
h5 {
    background-color: #d5ffb0;
    font-size: 90%;
	border-radius: 5px;
	padding: 3px;
	padding-top: 0;
	margin-top: 0;
	
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #154A7E;
	padding: 1px;
	border-radius: 5px;
}
ks{
	background-color: #E8FFD3;
	padding: 1px;
	padding-left: 3px;
	padding-right: 3px;
	border-radius: 5px;
	 
}
pre{
	font-family: "Consolas";
	font-size: 80%;
	background-color: #F8FFFD;
	border: 1.5px solid #90E4C8;
	padding: 10px;
	border-radius: 10px;
	overflow-x: auto;
	white-space: pre-wrap;
	white-space: -moz-pre-wrap;
	white-space: -pre-wrap;
	white-space: -o-pre-wrap;
	word-wrap: break-word;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
    font-size: 19px;
	line-height: 110%;
}    
div.cit{
	padding: 10px;
	margin: 5px;
    font-size: 18px;
	background-color: #EFF9F6;
	border-radius: 25px;
	border: 1px solid #d5f2ed;
}       
div.remark{
	background-color: #ffffff;	
    border: 1.5px solid #d5f2ed;
	padding-left: 20px;
	padding-right: 30px;
    margin: 10px;
	border-radius: 25px;
}  
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

ul{
	margin: 10px;
	margin-left: 20px;
	padding: 0;
}

li{
	padding-top: 5px;
}

table, th, td {
	border: 2px solid #d5f2ed;
}
td{
	padding: 10px;
}

#authors {
	width: 600px;
	border: 2px solid #AB55FF;
}

#authors td {
    background-color: #b2c0ff;
	padding: 10px;
	border: 2px solid #AB55FF;
}
i{
	font-weight: bold;
}
tl, ttr{
	color: #154A7E;
	font-weight: bold;
}
ttr{
	font-style: italic;
}
.mytab{
	tab-size: 4;
}
keyw{
	color: #B12283;
	font-weight: bold;
}
comm{
	color: #00BD06;
}
strs{
	color: #145CDE;
}
ints{
	color: #E7BE41;
	}
p.did{
	margin: 0;
	padding-bottom: 10px;
	padding-top: 0;
	padding-left: 15px;
	padding-right: 5px;
	font-size: 18px;
	border-left: 2px dashed silver;
}
sevid{
	background-color: #A8ECC7;
	border-radius: 5px;
	padding: 2px;
}
tevid{
	border-radius: 5px;
	padding: 2px;
	border: 2px solid #A8ECC7;
	line-height: 24px;
}
mevid{
	background-color: #D4F7E4;
}
change_evid{
	background-color: #FFFF99;
	border-radius: 5px;
	padding: 2px;
}
schange_evid{
	background-color: #FFE699;
	border-radius: 5px;
	padding: 2px;
}
tchange_evid{
	border-radius: 5px;
	padding: 2px;
	border: 2px solid #FFE699;
	line-height: 24px;
}
video{
	margin: 30px;
  -->
</style>
    
<head>
   
<title>Tearoom - sprint 4</title></head>
    
<body>
<div id="top">
<h1>Safe Tearoom COVID-19<font size="5"></font> </h1>
</div>  

<div class="body"> 

<!--<h2>Introduction</h2>
<div class="remark">
</div>-->

<h2>Specifics</h2>
<div class="remark">
	<h4>Introduction</h4>
	<p>At the end of the third Sprint the team was able to complete the development of the system as per customer requirements. However, the need to make some changes to our system subsequently emerged. This need arose from considerations that emerged during further internal team meetings, born in part from more in-depth tests carried out on the system and in part from the experience gained by the team during the previous sprints.</p>
	<p>In the following paragraphs, the updates performed on the system are briefly explained. More details about the components implementation will be given in the <i>Project</i> section of this document.</p>
	<h4>Updates</h4>
	<ul>
		<li>
			<h5>Optimized clean table interruption</h5>
			<p><i>Need</i> : After more in-depth tests carried out on the system, the team found out that after the waiter was interrupted while cleaning, even if there are more than one prioritized tasks in the queue, it won't perform all of them before returning to clean, but after the first task, it will return to the teatable just to interrupt the cleaning action immediately after to perform another prioritized task (and so on). This behavior is not wrong, but is extremely inefficient in terms of time, time that is wasted in the moving action between key points (for the prioritized tasks) and the table to clean.</p>
			
			<p><i>Solution</i> : before deciding if he can return to clean, it checks for other prioritized tasks in the queue and, if at least one is present, it performs them. Just after that it will return to cleaning action.</p>
		</li>
		<li>
			<h5>Simultaneous messages handling</h5>
			<p><i>Need</i> : Alcuni test più approfonditi hanno messo in evidenza un errore nella gestione, da parte di Waiter e Mastertimer, di alcune specifiche sequenze di messaggi che si verificano qualora due componenti del sistema inviino quasi contemporaneamente questi messaggi. In particolare di sotto sono riportate le sequenze di messaggi problematiche per il Waiter e per il Mastertimer:
				<ul>
					<li><u>Mastertimer</u>: può capitare che il Waiter e un Subtimer inviino in contemporanea rispettivamente uno stopTimer/endTimer e un timeoutSubtimer relativi allo stesso tavolo. Quando ciò accade è necessario che il Mastertimer gestisca il secondo messaggio arrivato tenendo conto del messaggio arrivato subito prima poichè se il Subtimer è già scaduto non avrebbe senso nè eseguire l'operazione di stopSubtimer nè quella di endSubtimer;</li>
					<li><u>Waiter</u>: può capitare che il Client e il Subtimer inviino in contemporanea rispettivamente un wantToOrder/billPlease e un timeout relativi allo stesso tavolo. Quando ciò accade è necessario che il Waiter gestisca il secondo messaggio arrivato tenendo conto del messaggio arrivato subito prima poichè se un Client è già stato accompagnato fuori non ha senso elaborare altri messagi relativi a lui.</li>
				</ul>
			</p>
			<p><i>Solution</i> : In entrambi i casi è necessario che Mastertimer e Waiter si ricordino rispettivamente di aver già gestito completamente un particolare Subtimer o un particolare cliente così che ulteriori messaggi che richiedono altre operazioni su di essi vengano scartati.</p>
		</li>
		<li>
			<h5>Testing with client</h5>
			<p><i>Need</i> : esenguendo test sempre più approfonditi sul sistema, è sorta la necessità di poter visualizzare, oltre alla GUI del client che consente di interfacciarsi con il waiter, anche le informazioni sulle attività del waiter, in modo da poter controllare in modo ancora migliore il suo funzionamento
			</p>
			<p><i>Solution</i> : poiché l'attività di osservazione degli stati del waiter era già presente nel manager, è stato sufficiente aggiungere tali funzionalità anche alla client GUI.
			</p>
		</li>
		<li>
			<h5>Observing the waiter to change</h5>
			<p><i>Need</i> : gli eventi che il waiter inviava al client, sono stati introdotti per permettere all'utente Mokkato di conoscere la posizione del waiter (i.e. quando il waiter è al tavolo e quindi cambiare la gui visualizzata). Poich1è però, il sistema dovrà avere a che fare con utenti reali, gli eventi che privano venivano ascoltati dalla gui, a quel punto verrebbero prodotti inutilmente. 
			</p>
			<p><i>Solution </i>: il waiter non ha più bisogno di inviare eventi per far conoscere la propria posizione, ma attraverso il meccanismo degli stati rende nota la sua posizione. la client gui a questo punto deve solo osservare il waiter e a ogni cambiamento di stato potrà aggiornarsi.
			</p>
		</li>
	</ul>
</div>

<h2>Project</h2>
<div class="remark">
	<h4>Structure</h4>
	<div>
		<ul>
			<li><h5>Logical Architecture</h5>
				<p>@TONNO perché non ci sono più eventi </p>
				<center><img src="img/prog_architecture.PNG" alt="logical architecture" width="100%"/></center>		
			</li>
			</br>
			<li>
				<h5>Manager architecture</h5>
				The Manager architecture remained unchanged and is summarized in the image below.  
				</br></br>
				<center><img src="img/proj_manager.png" alt="logical architecture" width="70%"/></center>
			</li></br>
			<li>
				<h5>Waiter architecture</h5>
				
				The Waiter architecture has not changed compared to what was defined in the @TONNO<a href="https://htmlpreview.github.io/?https://github.com/gitemar/Martini_Drudi_Safe_Tearoom/blob/master/week_2_step_1/userDocs/Progetto_Martini_Drudi.html">Sprint 1 project document</a>.
			</li>
		</ul>
	</div>
	<h4>Interaction</h4>
	<div>
		<p> No new form of interaction has been introduced in this fourth sprint, therefore what was discussed in all the previous Sprints, is still valid.</p>
	</div>
	<h4>Behaviour</h4>
	<div>
	<p>Compared to the previous Sprints, the waiter actor and mastertimer actor have undergone some optimization changes (as described in the "Updates" - section). Hereunder, their QAK models are reported and the changes highlighted.</p>
		<ul>
			<li><h5>Mastertimer QAK behaviour</h5>
				<pre class="mytab"><code><keyw>System</keyw> waiter
			
<keyw>mqttBroker</keyw> <strs>"localhost"</strs> : <ints>1883</ints> <keyw>eventTopic</keyw> "unibo/polar" 	<comm>//mqtt.eclipse.org</comm>

<comm>// Interaction Mastertimer - Waiter =================================//</comm>
<keyw>Dispatch</keyw> startTimer 	: startTimer(TEATABLE_ID, MAX_TIME)	   
<keyw>Dispatch</keyw> stopTimer 	: stopTimer(TEATABLE_ID)			   
<keyw>Dispatch</keyw> resumeTimer 	: resumeTimer(TEATABLE_ID)			   
<keyw>Dispatch</keyw> endTimer 		: endTimer(TEATABLE_ID)				   
<keyw>Dispatch</keyw> timeout 		: timeout(TEATABLE_ID)				   
<comm>//=============================================================//</comm>

<comm>// Interaction MasterTimer - SubTimers =========================//</comm>
<keyw>Dispatch</keyw> startSubtimer 		: startSubtimer(MAX_TIME)
<keyw>Dispatch</keyw> stopSubtimer 		: stopSubtimer(ARG)
<keyw>Dispatch</keyw> resumeSubtimer 	: resumeSubtimer(ARG)
<keyw>Dispatch</keyw> endSubtimer 		: endSubtimer(ARG)
<keyw>Dispatch</keyw> timeoutSubtimer 	: timeoutSubtimer(TEATABLE_ID)
<comm>//==============================================================//</comm></code></pre>
				<p>Per quanto riguarda la gestione dei messaggi simultanei può capitare che, come già detto sopra, il Mastertimer si trovi nella coda dei messaggi un timeoutSubtimer e un stopTimer/endTimer relativi allo stesso teatable. Ciò accade quando Subtimer e Waiter inviano questi messaggi contemporaneamente. Quattro sono i possibili casi da trattare:
					<ol>
						<li>
							<p>Il Mastertimer si trova nella coda prima un timeoutSubtimer e poi un stopTimer per lo stesso tavolo.</p>
							<p><i>Soluzione</i> : Il Mastertimer gestisce normalmente il timeoutSubtimer notificando il Waiter e inoltre si ricorda che il timer per quel tavolo è terminato (si dimenticherà di questa informazione alla successiva ricezione di StartTimer per quel tavolo). Quando è il momento di gestire lo stopTimer si ricorda che quel timer è già scaduto e quindi scarta il messaggio.</p>
						</li>
						<li>
							<p>Il Mastertimer si trova nella coda prima un stopTimer e poi un timeoutSubtimer per lo stesso tavolo.</p>
							<p><i>Soluzione</i> : Il Mastertimer gestisce normalmente lo stopTimer notificando il Subtimer corretto. Il Subtimer ignorerà il messaggio perchè è avendo terminato di contare si aspetta un messaggio di tipo StartSubtimer(discardMsg On). Successivamente riceve un timeoutSubtimer e lo gestisce normalmente notificando il Waiter. Sarà quindi compito del Waiter gestire correttamente il timeout arrivato dopo lo StopTimer.</p>
						</li>
						<li>
							<p>Il Mastertimer si trova nella coda prima un timeoutSubtimer e poi un EndTimer per lo stesso tavolo.</p>
							<p><i>Soluzione</i> : In questo caso il mastertimer gestisce normalmente il timeoutSubtimer notificando il Waiter e si ricorda che il timer per quel tavolo è scaduto (si dimenticherà di questa informazione alla successiva ricezione di StartTimer per quel tavolo). Quando è il momento di gestire il EndTimer si ricorda che quel timer è già scaduto e quindi scarta il messaggio.</p>
						</li>
						<li>
							<p>Il Mastertimer si trova nella coda prima un EndTimer e poi un timeoutSubtimer per lo stesso tavolo.</p>
							<p><i>Soluzione</i> : In questo caso il Mastertimer gestisce normalmente il EndTimer notificando il Subtimer corretto e si ricorda che quel timer è terminato (si dimenticherà di questa informazione alla successiva ricezione di StartTimer per quel tavolo). Il Subtimer ignorerà il messaggio perchè avendo terminato di contare si aspetta un messaggio di tipo StartSubtimer(discardMsg On). Successivamente quando è il momento di gestire il timeoutSubtimer si ricorda che il Waiter aveva già chiesto di terminare il timer e che quindi non è più interessato a ricevere un timeout per cui scarterà il messaggio.</p>
						</li>
					</ol>
				</p>
				<pre class="mytab"><code>QActor mastertimer context ctxwaiter {
	
	[#
		val map = mutableMapOf<Int, ActorBasic?>()
		var Teatable : Int
		
		val endedTimers = mutableMapOf<Int, Boolean?>()
	#]
	
	State s0 initial {
		discardMsg Off
		
		[#
			//map init: create timer to be immediately ready when Waiter want to use timers
			map.put(1, Subtimer("subtimer1", scope, context!!, 1))
			map.put(2, Subtimer("subtimer2", scope, context!!, 2))

			endedTimers.put(1, false)
			endedTimers.put(2, false)
			
			// waiting for subtimer to be created
			delay(1000)
		#]
	}
	Goto waitForCommand
	
	State waitForCommand{
		println("mastertimer | waiting for waiter's command...")
	}
	Transition t0 	whenMsg startTimer -> startTimer
					whenMsg stopTimer -> stopTimer
					whenMsg resumeTimer -> resumeTimer
					whenMsg endTimer -> endTimer
					whenMsg timeoutSubtimer -> handleTimeout
	
	State startTimer {
		onMsg(startTimer : startTimer(TABLE, TIME)){
			println("mastertimer | starting timer for teatable ${payloadArg(0)} and timeout ${payloadArg(1)} ms")
		    [#
		    	Teatable = payloadArg(0).toInt()
		    	endedTimers.put(Teatable, false)  //forget past end for simulaneus timeout/endTimer message handling
		    	forward("startSubtimer", "startSubtimer(${payloadArg(1)})" ,"${map.get(Teatable)!!.name}" )
		    #]

		}
		
	}
	Goto waitForCommand
	
	State stopTimer {
		onMsg(stopTimer : stopTimer(TABLE)) {
			
			 println("mastertimer | stopping timer for teatable ${payloadArg(0)}...")
			 [# Teatable = payloadArg(0).toInt()#]
			
			if [# endedTimers.get(Teatable)!! == true #] { //warning: simultaneously received stopTimer and timeout
					println("mastertimer | [stopTimer] ignoring message already handled...")
					//ignore message
			}
			else{
					println("mastertimer | stopping timer for teatable ${payloadArg(0)}...")
					[# forward("stopSubtimer", "stopSubtimer(arg)" ,"${map.get(Teatable)!!.name}" ) #]
					
			}

		}
	}
	Goto waitForCommand
	
	State resumeTimer {
		onMsg(resumeTimer : resumeTimer(TABLE)) {
			
			 println("mastertimer | resuming timer for teatable ${payloadArg(0)}...")
			 [#
		    	Teatable = payloadArg(0).toInt()
		    	forward("resumeSubtimer", "resumeSubtimer(arg)" ,"${map.get(Teatable)!!.name}" )
		    #]

		}
	}
	Goto waitForCommand
	
	State endTimer {
		onMsg(endTimer : endTimer(TABLE)) {
			
			 println("mastertimer | ending timer for teatable ${payloadArg(0)}...")
			  [# Teatable = payloadArg(0).toInt()#]
			
			if [# endedTimers.get(Teatable)!! == true #] { //warning: simultaneously received endTimer and timeout
					println("mastertimer | [endTimer] ignoring message already handled...")
					//ignore message
			}
			else{
					println("mastertimer | ending timer for teatable ${payloadArg(0)}...")
					[# forward("endSubtimer", "endSubtimer(arg)" ,"${map.get(Teatable)!!.name}" ) #]
					[# endedTimers.put(Teatable, true) #] //remember past end for simultaneous timeout/endTimer message handling 
			}

		}
	}
	Goto waitForCommand
	
	State handleTimeout {
		onMsg(timeoutSubtimer : timeoutSubtimer(TABLE)){
			[# Teatable = payloadArg(0).toInt()#]
			
			if [# endedTimers.get(Teatable)!! == true #] { //warning: simultaneously received endTimer/stopTimer and timeout
					println("mastertimer | [timeoutSubtimer] ignoring message already handled...")
					//ignore message
			}
			else{
				println("mastertimer | timeout for teatable $Teatable...")
				forward waiter -m timeout : timeout($Teatable)
				[#	endedTimers.put(Teatable, true) #] //remember past end for simultaneous timeout/endTimer/stopTimer message handling 
			}
		} 
	}
	Goto waitForCommand
}</code></pre>
			</li>
			<li><h5>Waiter QAK behaviour</h5>
			<pre class="mytab"><code><keyw>System</keyw> waiter
			
<keyw>mqttBroker</keyw> <strs>"localhost"</strs> : <ints>1883</ints> <keyw>eventTopic</keyw> "unibo/polar" 	<comm>//mqtt.eclipse.org</comm>

<comm>// Interaction Waiter - Mover =================================//</comm>
<keyw>Request</keyw> moveTo 	: moveTo(KEY_POSITION)						   
<keyw>Reply</keyw> done 		: done(X,Y)									   
<keyw>Dispatch</keyw> end 	: end(ARG)									  
<comm>//=============================================================//</comm>

<comm>// Interaction Waiter - MasterTimer =================================//</comm>
<keyw>Dispatch</keyw> startTimer 	: startTimer(TEATABLE_ID, MAX_TIME)	   
<keyw>Dispatch</keyw> stopTimer 	: stopTimer(TEATABLE_ID)			   
<keyw>Dispatch</keyw> resumeTimer 	: resumeTimer(TEATABLE_ID)			   
<keyw>Dispatch</keyw> endTimer 		: endTimer(TEATABLE_ID)				   
<keyw>Dispatch</keyw> timeout 		: timeout(TEATABLE_ID)				   
<comm>//=============================================================//</comm>

<comm>// Interaction Waiter - Tearoom ========================================//</comm>
<keyw>Request</keyw> getRoomState : getRoomState(REQUEST, ARG1)						
<keyw>Reply</keyw> state : state(STATE)
<keyw>Reply</keyw> numBusyAndDirty : numBusyAndDirty(BUSY,DIRTY)
<keyw>Dispatch</keyw> updateState : updateState (UPDATE_REQUEST, ARG1, ARG2, ARG3)	
<comm>//======================================================================//</comm>

<comm>// Interaction Waiter - Smartbell ============================//</comm>
<keyw>Dispatch</keyw> enter : enter(CLIENT_ID)						      
<comm>//============================================================//</comm>

<comm>// Interaction Waiter - Client ===============================//</comm>
<keyw>Dispatch</keyw> wantToOrder	: wantToOrder(TEATABLE_ID)	          	  
<keyw>Dispatch</keyw> tea 			: tea(TEATABLE_ID, TEA)				    
<keyw>Dispatch</keyw> billPlease 	: billPlease(TABLE_ID)			  
<comm>//============================================================//</comm>

<comm>// Interaction Waiter - Barman  ==============================//</comm>
<keyw>Dispatch</keyw> order : order(TEATABLE_ID, TEA)					  
<keyw>Dispatch</keyw> ready : ready(TEATABLE_ID,TEA)						  
<comm>//============================================================//</comm>

<comm>// Interaction Waiter auto-message ===========================//</comm>
<keyw>Dispatch</keyw> cleanTable : cleanTable (TEATABLE_ID)				  
<comm>//============================================================//</comm></code></pre>
		
		<p><i>Optimized clean table interruption</i> : as mentioned above (Updates section), before returning to the cleaning action after it was interrupted, the waiter checks if there are any prioritized tasks (state <u>checkForOtherPrioritizedTasks</u>). If there are, it performs them.</p>
		<p><i>Simultaneous messages</i> : per quanto riguarda la gestione dei messaggi simultanei può capitare che, come già detto sopra, il Waiter si trovi nella coda dei messaggi un timeout e un wantToOrder/billPlease relativi allo stesso teatable (all'interno della safe tearoom ogni cliente è associato univocamente ad un tavolo). Ciò accade quando Client e Mastertimer inviano questi messaggi contemporaneamente. Quattro sono i possibili casi da trattar
			<ol>
				<li>
					<p>Il Waiter si trova nella coda prima un timeout e poi un WantToOrder per lo stesso tavolo.</p>
					<p><i>Soluzione</i> : In questo caso il Waiter gestisce normalmente il timeout notificando il Client e facendolo uscire dalla tearoom. Si ricorda inoltre che il cliente a quel tavolo è già stato gestito completamente (si dimenticherà di questa informazione quando assegnerà il tavolo ad un nuovo cliente). Successivamente quando è il momento di gestire il WantTOrder il Waiter si ricorda che il cliente è già stato gestito e scarterà il messaggio.</p>
				</li>
				<li>
					<p>Il Waiter si trova nella coda prima un wantToOrder e poi un timeout per lo stesso tavolo.</p>
					<p><i>Soluzione</i> : In questo caso il Waiter gestisce normalmente il WantToOrder andando a prendere l'ordine del cliente e chiedendo al Barman di preparare l'ordine. Successivamente gestisce normalmente il timeout facendo pagare il cliente e scortandolo all'uscita. Inoltre si ricorda di aver completato la gestione di quel tavolo (informazione che si dimentica quando assegna quel tavolo ad un nuovo cliente). Quando poi successivamente riceve un messaggio ready dal barman per quel tavolo si ricorda che il cliente è già stato fatto uscire e lo scarta.</p>
				</li>
				<li>
					<p>Il Waiter si trova nella coda prima un timeout e poi un billPlease per lo stesso tavolo.</p>
					<p><i>Soluzione</i> : In questo caso il Waiter gestisce normalmente il timeout notificando il Client e facendolo uscire dalla tearoom. Si ricorda inoltre che il cliente a quel tavolo è già stato gestito completamente (si dimenticherà di questa informazione quando assegnerà il tavolo ad un nuovo cliente). Successivamente quando è il momento di gestire il billPlease il Waiter si ricorda che il cliente è già stato gestito e scarterà il messaggio.</p>
				</li>
				<li>
					<p>Il Waiter si trova nella coda prima un billPlease e poi un timeout per lo stesso tavolo.</p>
					<p><i>Soluzione</i> : In questo caso il Waiter gestisce normalmente il billPlease facendo pagare il Cliente e scortandolo poi all'uscita. Si ricorda inoltre che il cliente a quel tavolo è già stato gestito completamente (si dimenticherà di questa informazione quando assegnerà il tavolo ad un nuovo cliente). Successivamente quando è il momento di gestire il timeout il Waiter si ricorda che il cliente è già stato gestito e scarterà il messaggio.</p>
				</li>
			</ol>
		</p>
		
		<pre class="mytab"><code>Context ctxwaiter 		 	ip [host="127.0.0.1" port=8029]
Context ctxtearoom 		 	ip [host="localhost" port=8015]

ExternalQActor tearoom 		context ctxtearoom
ExternalQActor barman		context ctxtearoom
ExternalQActor smartbell	context ctxtearoom

CodedQActor datacleaner    	context ctxwaiter className "rx.dataCleaner"
CodedQActor distancefilter 	context ctxwaiter className "rx.distanceFilter"
CodedQActor basicrobot 		context ctxwaiter className "it.unibo.basicrobot.Basicrobot"
CodedQActor trustingwalker 	context ctxwaiter className "it.unibo.trustingwalker.Trustingwalker"



<sevid>QActor waiter</sevid> context ctxwaiter {
	
	[# 
		var MaxWaitTime = 0L
		val MaxStayTime = 20000L   	// 1min
		val IdleTime = 200L	
		val MaxCleanTime = 5000L			// 200 ms
		
		var ClientToConvoy = ""
		var DestTable = -1
		var CurDrink = ""
		var Price = 3
		
		var TimeToClean = MaxCleanTime
		var TimeCleanBegan = 0L
		var WasCleaning = false
		var TableToClean = 0
		
		<change_evid>val stopHandlingClientAtTable = mutableMapOf<Int, Boolean?>()</change_evid>
		var stopCheck = false
	#]
	
	
	<sevid>State s0 initial</sevid> {
		
		//init
		println("waiter | beep beep boop...START...")
		<change_evid>[# stopHandlingClientAtTable.put(1, false) #]</change_evid>
		<change_evid>[# stopHandlingClientAtTable.put(2, false) #]</change_evid>
		discardMsg Off
	}
	<tevid>Goto restingAtHome</tevid>
	
	// WAITER WAIT FOR TASK TO DO 1
	<sevid>State restingAtHome</sevid> {
			
		println("waiter | Chilling out at home...")	
		updateResource[#"atPosition(0,0,home)"#]
		
	}
	<tevid>Transition t0 	whenMsg enter -> handleEnterPhase1</tevid>
					<tevid>whenMsg wantToOrder -> handleOrderFromClientPhase0</tevid>
					<tevid>whenMsg ready -> serveTeaToClientPhase0</tevid>
					<tevid>whenMsg timeout -> handleTimeoutPhase0</tevid>
					<tevid>whenMsg billPlease -> handlePaymentPhase0 </tevid>
					<tevid>whenMsg cleanTable -> cleanTeatablePhase1</tevid>
	
	// WAITER WAIT FOR TASK TO DO 2
	<sevid>State doATask</sevid> {
		
		println("waiter | checking if there is a task to do...")
		
	}
	<tevid>Transition t0 	whenTimeVar IdleTime -> goHome</tevid>			
					<tevid>whenMsg enter -> handleEnterPhase1</tevid>
					<tevid>whenMsg wantToOrder -> handleOrderFromClientPhase0</tevid>
					<tevid>whenMsg ready -> serveTeaToClientPhase0</tevid>
					<tevid>whenMsg timeout -> handleTimeoutPhase0</tevid>
					<tevid>whenMsg billPlease -> handlePaymentPhase0 </tevid>
					<tevid>whenMsg cleanTable -> cleanTeatablePhase1</tevid>
	
	// WAITER GO HOME
	<sevid>State goHome</sevid> {
		
		updateResource[#"goingHome"#]
		request mover -m moveTo : moveTo(home)
		
	}
	<tevid>Transition t0 whenReply done -> restingAtHome</tevid>


	<comm>/******************  WAITER HANDLE ENTER REQUEST ********************************************************************/</comm>
	
	<sevid>State handleEnterPhase1</sevid> {
		println("waiter | enter message arrived")
		onMsg(enter : enter(CLIENT_ID)){
			if [# WasCleaning == true #]{
				[# var TempTime = 0L #]
				memoCurrentTime TempTime
				[# TimeToClean = TimeToClean - (TempTime - TimeCleanBegan) #]
				println("waiter | interrupted cleaning to handle enter request")
			}
			[#ClientToConvoy = payloadArg(0)#]
			println("waiter | a client with client_id ${payloadArg(0)} asked to enter the safe tearoom...")
			println("waiter | checking if the safe tearoom has a free table ...")
			request tearoom -m getRoomState : getRoomState(getFreeTable, arg1)
		} //onMsg
		
	}
	<tevid>Transition t0 whenReply state -> handleEnterPhase2</tevid>
	
	<sevid>State handleEnterPhase2</sevid> {
		println("waiter | state response arrived")
		onMsg(state : state(S)){
			if [#payloadArg(0).toInt() == 0 #] { //NO free and clean table (CAN'T HAPPEN in this first prototype since there is only one client)
				[#MaxWaitTime = 1L#]
				println("waiter | But there is no free and clean teatable")
			}
			else { // there is a free and clean table and Tearoom sent me it's ID
				[# 
					MaxWaitTime =  0L
					DestTable = payloadArg(0).toInt()
				#]
			}
		}
		println("waiter | waittime: $MaxWaitTime")
	}
	<tevid>Goto convoyClientToTablePhase1 if [# MaxWaitTime == 0L #] else requestTableStates</tevid>
	
	<sevid>State requestTableStates</sevid>{
		println("waiter | requesting teatable states to tearoom...")
		request tearoom -m getRoomState : getRoomState(getBusyAndDirtyTables, arg1)
	}
	<tevid>Transition t0 whenReply numBusyAndDirty -> analyzeTableStates</tevid>
	
	<sevid>State analyzeTableStates</sevid>{
		onMsg(numBusyAndDirty : numBusyAndDirty(B,D)){
			println("waiter | tearoom replied with ${payloadArg(0)}-${payloadArg(1)} (busy-dirty)")
			[#
				val b=payloadArg(0).toInt()
				val d=payloadArg(1).toInt()
				var totTime = 0L
				if(d>0){
					totTime = MaxCleanTime
				}
				else{
					totTime = MaxStayTime
				}
				MaxWaitTime = totTime
			#]
			println("waiter | client has to wait at least $MaxWaitTime minutes")
			<change_evid>updateResource[#"newClient($ClientToConvoy):clientWaiting:$ClientToConvoy:$MaxWaitTime"#]</change_evid>
			delay 800
		}
	}
	<tchange_evid>Goto doATask if [# WasCleaning == false #] else checkForOtherPrioritizedTasks</tchange_evid>
	
	
	
	<comm>/*************  WAITER CONVOY CLIENT TO TABLE *************************************************************************/</comm>
	
	<sevid>State convoyClientToTablePhase1</sevid> {
		<change_evid>updateResource[#"reachingPosition(entrance)"#]</change_evid>
		println("waiter | reaching entrance door to convoy client $ClientToConvoy to teatable $DestTable ...")
		request mover -m moveTo : moveTo(entrance)
	}
	<tevid>Transition t0 whenReply done -> convoyClientToTablePhase2</tevid>
	
	<sevid>State convoyClientToTablePhase2</sevid> {
		onMsg(done : done(X,Y)){
			<change_evid>updateResource[#"atPosition(entrance,${payloadArg(0)},${payloadArg(1)}):clientEntering:$ClientToConvoy:$MaxWaitTime"#]</change_evid>
			delay 500
			<change_evid>updateResource[#"convoyingClientToTable($DestTable,$ClientToConvoy)"#]</change_evid>
			println("waiter | convoying client $ClientToConvoy to teatable $DestTable ...")
			[#var Dest =  "teatable" + DestTable.toString() #]
			request mover -m moveTo : moveTo($Dest)
		}
	}
	<tevid>Transition t0 whenReply done -> convoyClientToTablePhase3</tevid>
		
	<sevid>State convoyClientToTablePhase3</sevid> {
		onMsg(done : done(X,Y)){
			println("waiter | Start mastertimer, update tearoom and telling client to sit")
			forward tearoom -m updateState : updateState (updateTableState, $DestTable, busy, $ClientToConvoy)
			<change_evid>updateResource[# "atPosition(teatable$DestTable,${payloadArg(0)},${payloadArg(1)}):clientSitting:$ClientToConvoy:$DestTable" #]</change_evid>
			//refresh information in stopHandlingClientAtTable to correctly handle case of simultaneous timeout/billPlease/wantToOrder
			[# stopHandlingClientAtTable.put(DestTable, false) #]
			//start timer to count until MaxStayTime
			delay 500
			forward mastertimer -m startTimer : startTimer($DestTable, $MaxStayTime)
		}
		
	}
	<tchange_evid>Goto doATask if [# WasCleaning == false #] else checkForOtherPrioritizedTasks</tchange_evid>
	
	<comm>/****************************************************************************************************/</comm>
	
	<comm>/**************************************  WAITER CLEAN TABLE **************************************/</comm>
	
	State cleanTeatablePhase1 {
		
		[# var Dest="" #]
		
		onMsg(cleanTable : cleanTable(T)) {
			println("Waiter moving towards teatable to clean (${payloadArg(0)})")
			[#
			  Dest =  "teatable" + payloadArg(0) 
			  DestTable = payloadArg(0).toInt()
			  TableToClean = payloadArg(0).toInt()
			#]
		}
		
		//resuming cleaning if waiter was cleaning
		if[# WasCleaning == true #]{
			println("Waiter moving towards teable $TableToClean to resume cleaning")
			[#
			  Dest =  "teatable" + TableToClean
			  DestTable = TableToClean
			#]
		}
		
		updateResource[#"cleaning($DestTable)"#]
		//first we reach the table
		request mover -m moveTo : moveTo($Dest)
	}
	Transition t0 whenReply done -> cleanTeatablePhase2
	
	
	State cleanTeatablePhase2 {
		
		// then we clean the teatable
		println("waiter | cleaning teatable $TableToClean")
		[#
			WasCleaning = true
		#]	
		memoCurrentTime TimeCleanBegan
	}
	Transition t1 whenTimeVar TimeToClean -> finishedClean
				  whenMsg ready -> serveTeaToClientPhase0
				  whenMsg enter -> handleEnterPhase1
				  whenMsg wantToOrder -> handleOrderFromClientPhase0
				  whenMsg billPlease -> handlePaymentPhase0
				  
	State finishedClean{
		
		println("waiter | finished cleaning teatable $TableToClean")
		//update teatable state
		forward tearoom -m updateState : updateState (updateTableState, $TableToClean, clean, ARG3)
		[# 
			WasCleaning = false
			TimeToClean = 2000L
			TableToClean = 0
			TimeCleanBegan = 0L
		#]
	}
	Goto doATask
	
	State checkForOtherPrioritizedTasks{
		//checking if there are other tasks that are prioritized (that would interrupt cleaning action)
		//if there is one, the waiter does that task
		//this way it won't return to the table to start cleaning and interrupt immediately after
	}
	Transition t0 whenTimeVar IdleTime -> cleanTeatablePhase1
				  whenMsg ready -> serveTeaToClientPhase1
				  whenMsg enter -> handleEnterPhase1
				  whenMsg wantToOrder -> handleOrderFromClientPhase1
				  whenMsg billPlease -> handlePaymentPhase1
				  
	State checkIfWasCleaning{
		//
	}
	Goto cleanTeatablePhase1 if [# WasCleaning == true #] else doATask
	
		
	<comm>/****************************************************************************************************/</comm>
	
	<comm>/**************************************  WAITER TAKE CLIENT's ORDER **************************************/</comm>	
		
	
	State handleOrderFromClientPhase0{
		onMsg(wantToOrder : wantToOrder(TEATABLE_ID)){
			
			if [# WasCleaning == true #]{
				[# var TempTime = 0L #]
				memoCurrentTime TempTime
				[# TimeToClean = TimeToClean - (TempTime - TimeCleanBegan) #]
				println("waiter | interrupted cleaning to handle order request")
			}
			
			[# var Teatable = payloadArg(0).toInt() #]
			
			//Was wantToOrder sent after a timeout for that client was triggered?
			if [# stopHandlingClientAtTable.get(Teatable)!! == true #] { 
					println("waiter | ignoring wantToOrder message for table $Teatable since it's client timed-out...")
					[# stopCheck = true #]
					//ignore message
			}
			else{
					//Stop timer: stop counting for orderTime now!
					forward mastertimer -m stopTimer : stopTimer($payloadArg(0))
					println("waiter | client at teatable $Teatable want to order! Reaching table $Teatable...")
					
					[# stopCheck = false #]
					//NOTE: in this case there is no need to change stopHandlingClientAtTable value! Only timeout or billplease must change it
					//memorizing teatable_id for next phase
					[#
						DestTable = Teatable
					#]
			}
		}
	}
	Goto handleOrderFromClientPhase1 if [# stopCheck == false #] else checkIfWasCleaning
	
	State handleOrderFromClientPhase1 {
			[#
				var Dest =  "teatable" + DestTable
			#]
			updateResource[#"reachingPosition(teatable$DestTable)"#]
			request mover -m moveTo : moveTo($Dest)
	}
	Transition t0 whenReply done -> handleOrderFromClientPhase2
	
	State handleOrderFromClientPhase2 {
		onMsg(done : done(X,Y)){
			println("waiter | client can now order...")
			updateResource[# "atPosition(teatable$DestTable,${payloadArg(0)},${payloadArg(1)}):clientOrdering:$DestTable" #]
	//		emit orderPlease : orderPlease($DestTable)
		}
	}
	Transition t0 whenMsg tea -> handleOrderFromClientPhase3
	
	State handleOrderFromClientPhase3 {
		
		onMsg(tea : tea(TABLE,TEA)){
			println("waiter | client at teatable ${payloadArg(0)} ordered a ${payloadArg(1)}! Sending order to Barman...")
			forward barman -m  order : order($payloadArg(0), $payloadArg(1))
		}
		
	}
	Goto checkForOtherPrioritizedTasks if [# WasCleaning == true #] else doATask
	
	
	<comm>/****************************************************************************************************/</comm>
	
	<comm>/**************************************  WAITER SERVE CLIENT  **************************************/</comm>
	
	State serveTeaToClientPhase0 {
		onMsg(ready : ready(T,D)){
			
			if [# WasCleaning == true #]{
				[# var TempTime = 0L #]
				memoCurrentTime TempTime
				[# TimeToClean = TimeToClean - (TempTime - TimeCleanBegan) #]
				println("waiter | interrupted cleaning to serve")
			}
			
			[# var Teatable = payloadArg(0).toInt() #]
				
			//Se mi arriva contemporaneamente un wantToOrder e subito dopo un timeout...??? Ormai ho inviato la richiesta di fare un piatto...
			// devo ignorare il ready!
			
			//Was wantToOrder sent just before a timeout for that client was triggered? Then this client is no more inside the tearoom and waiter should ignore
			// this message
			if [# stopHandlingClientAtTable.get(Teatable)!! == true #] { 
					println("waiter | ignoring ready message for table $Teatable since it's client is no more inside the tearoom...")
					[# stopCheck = true #]
					//ignore message
			}
			else{
					[# stopCheck = false #]
					
					//memorizing some information for next phase
					[#
						DestTable = Teatable
						CurDrink = payloadArg(1)
					#]
			}
			
		}
	}
	Goto serveTeaToClientPhase1 if [# stopCheck == false #] else checkIfWasCleaning
	
	State serveTeaToClientPhase1 {
		updateResource[#"reachingPosition(servicedesk)"#]
		println("waiter | order for table $DestTable ready! Reaching service desk...")
		request mover -m moveTo : moveTo(servicedesk)
				
	}
	Transition t0 whenReply done -> servTeaToClientPhase2
	
	State servTeaToClientPhase2 {
		
		onMsg(done : done(X,Y)){
			updateResource[#"atPosition(servicedesk,${payloadArg(0)},${payloadArg(1)}):tea($CurDrink,$DestTable)"#]
			delay 500
			println("waiter | bringing tea to table $DestTable...")
			[#var Dest =  "teatable" + DestTable #]
			updateResource[#"reachingPosition(teatable$DestTable):servingTea($CurDrink)"#]	
			request mover -m moveTo : moveTo($Dest)
		
		}
			
	}
	Transition t0 whenReply done -> servTeaToClientPhase3
	
	State servTeaToClientPhase3 {
			onMsg(done : done(X,Y)){
				updateResource[#"atPosition(teatable$DestTable,${payloadArg(0)},${payloadArg(1)}):teaServed:$DestTable:$CurDrink"#]
				delay 1000
				//emit teaServed : teaServed($DestTable, $CurDrink )
				//start counting for consumingTime NOW
				//start timer to count until MaxStayTime
				println("Waiter resuming rimer for client...")
				forward mastertimer -m resumeTimer : resumeTimer($DestTable)
				
			}
	}		
	Goto checkForOtherPrioritizedTasks if [# WasCleaning == true #] else doATask
	
	<comm>/****************************************************************************************************/</comm>
	
	<comm>/**************************************  WAITER HANDLE PAYMENT **************************************/</comm>
	
	State handlePaymentPhase0 {
		onMsg(billPlease : billPlease(T)){
			
			if [# WasCleaning == true #]{
				[# var TempTime = 0L #]
				memoCurrentTime TempTime
				[# TimeToClean = TimeToClean - (TempTime - TimeCleanBegan) #]
				println("waiter | interrupted cleaning to handle payment request")
			}
			
			[# var Teatable = payloadArg(0).toInt() #]
			
			//Was billPlease sent after a timeout for that client was triggered?
			if [# stopHandlingClientAtTable.get(Teatable)!! == true #] { 
					println("waiter | ignoring billPlease message for table $Teatable since it's client timed-out...")
					[# stopCheck = true #]
					//ignore message
			}
			else{
					// stopping timer
					println("waiter | Client at table $Teatable is ready to pay. Ending timer for table $Teatable")
					forward mastertimer -m endTimer : endTimer($payloadArg(0))
		
					
					[# stopHandlingClientAtTable.put(Teatable, true) #] //remember past end for simultaneous timeout/billPlease message handling 
					[# stopCheck = false #]
					
					//memorizing teatable_id for next phase
					[#
						DestTable = Teatable
					#]
			}
		}
	}
	Goto handlePaymentPhase1 if [# stopCheck == false #] else checkIfWasCleaning
	
	State handlePaymentPhase1{
		
		// reaching table
		println("waiter | Reaching table ${payloadArg(0)} ...")
		updateResource[#"reachingPosition(teatable$DestTable)"#]
		[# var Dest = "teatable" + DestTable #]
		request mover -m moveTo : moveTo($Dest)
	}
	Transition t0 whenReply done -> handlePaymentPhase2
	
	State handlePaymentPhase2 {
		
		onMsg(done : done(X,Y)){
			println("waiter | Asking Client at table $DestTable to pay ...")
			updateResource[#"atPosition(teatable$DestTable,${payloadArg(0)},${payloadArg(1)}):clientPaying:$DestTable"#]
			delay 500
//			emit cardPlease : cardPlease($DestTable) 
			//get client_id from table_id
			request tearoom -m getRoomState : getRoomState(getClientFromTable, $DestTable)
		
		} 
	}
	Transition t0 whenReply state -> convoyClientToExitPhase1
	
	State convoyClientToExitPhase1 {
		onMsg(state : state(C)){
			println("waiter | Convoying Client ${payloadArg(0)} to exit door ...")
			[# ClientToConvoy = payloadArg(0)#]
			updateResource[#"convoyingClientToExitDoor($ClientToConvoy)"#]
			request mover -m moveTo : moveTo(exit)
		}
	}
	Transition t0 whenReply done -> convoyClientToExitPhase2
	
	State convoyClientToExitPhase2 {
		onMsg(done : done(X,Y)){
			println("waiter | saying goodbye to client $ClientToConvoy...")
			updateResource[#"atPosition(exit,${payloadArg(0)},${payloadArg(1)}):clientExiting:$ClientToConvoy"#]
//			emit exitPlease : exitPlease($ClientToConvoy)
			delay 500
			//updating teatable state
			forward tearoom -m updateState : updateState(updateTableState, $DestTable, dirty, ARG)
			//remember to clean the table
			forward waiter -m cleanTable : cleanTable($DestTable)
		}
	}
	Goto checkForOtherPrioritizedTasks if [# WasCleaning == true #] else doATask
	
	<comm>/****************************************************************************************************/</comm>
	
	<comm>/**************************************  WAITER HANDLE SLOW CLIENT **************************************/</comm>
	
	
	State handleTimeoutPhase0 {
		println("waiter | inside handleTimeoutPhase0")
		onMsg(timeout : timeout(T)){
			println("waiter | inside handleTimeoutPhase0 AND onMsg!")
			[# var Teatable = payloadArg(0).toInt() #]
			
			//if already receive a billPlease it's a case of simultaneously billPlease - timeout
			if [# stopHandlingClientAtTable.get(Teatable)!! == true #] { 
					println("waiter | ignoring timeout message for table $Teatable since it's client was already handled...")
					[# stopCheck = true #]
					//ignore message
			}
			else{
					println("waiter | Time exceeded for client at table $Teatable")
					println("waiter | reaching table $Teatable...")
					[# stopHandlingClientAtTable.put(Teatable, true) #] //remember past end for simultaneous timeout/billPlease/wantToOrder message handling 
					[# stopCheck = false #]
					
					[#
						DestTable = Teatable	
					#]
			}
		}
	}
	Goto handleTimeoutPhase1 if [#stopCheck == false#] else doATask
	
	State handleTimeoutPhase1 {
		
		updateResource[#"reachingPosition(teatable$DestTable)"#]
		[# var Dest = "teatable" + DestTable #]
		request mover -m moveTo : moveTo($Dest)
		
	}
	Transition t0 whenReply done -> handleTimeoutPhase2
	
	State handleTimeoutPhase2 {
		onMsg(done : done(X,Y)){
			updateResource[#"atPosition(teatable$DestTable,,${payloadArg(0)},${payloadArg(1)}):maxTimeExceeded:$DestTable"#]
			println("waiter | communicating to client at table ${payloadArg(0)} that he has to pay and leave...")
//			emit maxTimeExceeded : maxTimeExceeded($payloadArg(0), $Price)	
			delay 800			
			//get client_id from table_id
			request tearoom -m getRoomState : getRoomState(getClientFromTable, $DestTable)	
		}
			
	}
	Transition t0 whenReply state -> convoyClientToExitPhase1	
	
}</code></pre>
			</li>
		</ul>
	</div>	
</div>

<h2>Test Plans</h2>
<div class="remark">

	<h4>Client MOK - WebGUI</h4>
	<div>
		<p>
			@TONNO spiegare integrazione di manager con client e la conseguente gestione dei cambiamenti di stato tramite WaiterUpdateResourceHandler (e che il resto non cambia + link a documenti)
		</p>
		<p>Hereunder is reported the @Controller class. The parts taking care of the aforementioned aspecs will be highlighted: </p>
		<pre class="mytab"><code>@Controller
public class ProvaController {
	
	String appName     ="provaGui";
    String htmlPage  = "welcome";
    ConnQakCoapMine connQakSupportS;
    ConnQakCoapMine connQakSupportW;
    ConnQakCoapMine connQakSupportT;
    ConnQakCoapMine connQakSupportB;
   
    @Autowired
    ClientAttributes ca;
    
    @Autowired
    SimpMessagingTemplate smt;
    
    String[] tavoliClienti = {"",""};
    String stateT ="";
    String stateW ="";
    String stateB ="";
    ProvaController controller=this;
   
	public ProvaController() {
        connQakSupportS = new ConnQakCoapMine();
        connQakSupportW = new ConnQakCoapMine();
        connQakSupportT = new ConnQakCoapMine();
        connQakSupportB = new ConnQakCoapMine();
       
        connQakSupportS.createConnection("localhost", "8015", "ctxtearoom", "smartbell");
         <change_evid>stateB = connQakSupportB.createConnection("localhost", "8015", "ctxtearoom", "barman");</change_evid>
         <change_evid>stateW = connQakSupportW.createConnection("127.0.0.1", "8029", "ctxwaiter", "waiter");</change_evid>
         <change_evid>stateT = connQakSupportT.createConnection("localhost", "8015", "ctxtearoom", "tearoom");</change_evid>
  
	}
	
	
	/*--------------------------------------------MAPPING-----------------------------------------------------------*/
	
	@GetMapping("/")
	public String welcomePage(Model model, HttpSession s){
		
		System.out.println("________________________Welcome page requested: " + s.getId());
		
		 <change_evid>preparePageUpdating();</change_evid>
		try {
			Thread.sleep(350);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		 <change_evid>model.addAttribute("ts", stateT);</change_evid>
		 <change_evid>model.addAttribute("ws", stateW);</change_evid>
		 <change_evid>model.addAttribute("bs", stateB);</change_evid>
		return "welcome";
		
	}
	
	@PostMapping("/enter")
	public String afterRingPage(Model model, HttpServletResponse r) {
		System.out.println("________________________Client rang the smartbell... "+model);
		
		try {
			ApplMessage msg = MsgUtil.buildRequest("clientWebPage", "ring", "ring()", "smartbell");
			String answer = connQakSupportS.request( msg );
			
			while(!(model!=null)) {
				System.out.println("________________________Waiting for smartbell reply...");
				Thread.sleep(200);
			}
			
			System.out.println("_______________________Smartbell reply: "+answer);
			String html = this.getAccessResult(answer, model);
			r.addCookie(new Cookie("id",ca.getId()));
			r.addCookie(new Cookie("table","0"));

			try {
				Thread.sleep(350);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			 <change_evid>model.addAttribute("ts", stateT);</change_evid>
			 <change_evid>model.addAttribute("ws", stateW);</change_evid>
			 <change_evid>model.addAttribute("bs", stateB);</change_evid>
			return ""+html;	
		}
		catch(Exception e) {
			System.out.println("_________________________ERROR=" + e.getMessage());
			e.printStackTrace();
			
			try {
				Thread.sleep(350);
			} catch (InterruptedException er) {
				// TODO Auto-generated catch block
				er.printStackTrace();
			}
			 <change_evid>model.addAttribute("ts", stateT);</change_evid>
			 <change_evid>model.addAttribute("ws", stateW);</change_evid>
			 <change_evid>model.addAttribute("bs", stateB);</change_evid>
			return "welcome";
		}
	}
	
	@PostMapping("/order")
	public String wantToOrder(Model model, HttpServletResponse r){
		
		int tid = indexOf(ca.getId()) + 1;		
		ca.setTable(tid);
		System.out.println("_______________________Client wants to order...");
		connQakSupportW.forward(MsgUtil.buildDispatch(ca.getId(), "wantToOrder", "wantToOrder("+ca.getTable()+")", "waiter"));
		r.addCookie(new Cookie("id",ca.getId()));
		r.addCookie(new Cookie("table",""+ca.getTable()));

		try {
			Thread.sleep(350);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		 <change_evid>model.addAttribute("ts", stateT);</change_evid>
		 <change_evid>model.addAttribute("ws", stateW);</change_evid>
		 <change_evid>model.addAttribute("bs", stateB);</change_evid>
		return "order";
	}
	
	@PostMapping("/consume")
	public String afterOrder(@RequestParam String type, Model model, HttpServletResponse r){
		
		System.out.println("_______________________Client has requested " + type + " tea...");		
		connQakSupportW.forward(MsgUtil.buildDispatch("clientWebPage", "tea", "tea("+ca.getTable()+","+type+")", "waiter"));
		r.addCookie(new Cookie("id",ca.getId()));
		r.addCookie(new Cookie("table",""+ca.getTable()));
		model.addAttribute("teaOrdered", type);

		try {
			Thread.sleep(350);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		 <change_evid>model.addAttribute("ts", stateT);</change_evid>
		 <change_evid>model.addAttribute("ws", stateW);</change_evid>
		 <change_evid>model.addAttribute("bs", stateB);</change_evid>
		return "consume";
	}
	

	@PostMapping("/exit")
	public String afterOrder(Model model, HttpServletResponse r){
		
		System.out.println("_______________________Client has requested  the bill...");		
		connQakSupportW.forward(MsgUtil.buildDispatch(ca.getId(), "billPlease", "billPlease("+ca.getTable()+")", "waiter"));
		r.addCookie(new Cookie("id",ca.getId()));
		r.addCookie(new Cookie("table",""+ca.getTable()));

		try {
			Thread.sleep(350);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		 <change_evid>model.addAttribute("ts", stateT);</change_evid>
		 <change_evid>model.addAttribute("ws", stateW);</change_evid>
		 <change_evid>model.addAttribute("bs", stateB); </change_evid>
		return "exit";
	}
	
	
	/*-------------------------------------------UTILITIES------------------------------------------------------------*/
	
	public void updateWaiterResp(String testo, String topic) {
		smt.convertAndSend(topic, testo);
		System.out.println("____________________________Updating client web-view...");
		System.out.println("TOPIC: "+topic+"\nTESTO: "+testo);
	}	
	
	public String getAccessResult(String msg, Model m) {
		
		String msgArg = KotParser.getMessageArg(msg, "sendClientID");
		System.out.println(msgArg);
		String ret = "welcome";
		
		if(msgArg.equals("NO")) {
			System.out.println("________________________The client cannot enter... "+m);
			ret = "noAccess";
		}
		else {
			System.out.println("________________________The client can enter... "+m);
			m.addAttribute("waiterResp", "Waiting for waiter instructions...");
			ca.setId(msgArg);
			ret = "enter";
		}
		
		return ret;
		
	}


	public String[] getTavoliClienti() {
		return tavoliClienti;
	}

	private int indexOf(String id) {
		if(tavoliClienti[0].equals(id)) {
			return 0;
		}
		else {
			if(tavoliClienti[1].equals(id)) {
				return 1;
			}
			else
				return -1;
		}
	}
	
	 <change_evid>private void preparePageUpdating() {
	    	connQakSupportT.getClient().observe(new CoapHandler() {
				@Override
				public void onLoad(CoapResponse response) {
					stateT = response.getResponseText();
					System.out.println("MonitorController --> CoapClient changed ->" + stateT);
					System.out.println("_____________________Updating manager web view...");
					System.out.println("TOPIC: "+WebSocketConfig.topicForManager1+"\nTESTO: "+stateT);
					smt.convertAndSend(WebSocketConfig.topicForManager1, 
							new ResourceRepMine("" + HtmlUtils.htmlEscape(stateT)));
				}

				@Override
				public void onError() {
					System.out.println("MonitorController --> CoapClient error!");
				}
			});
	    	connQakSupportW.getClient().observe(new CoapHandler() {
				@Override
				public void onLoad(CoapResponse response) {
					stateW = response.getResponseText();
					System.out.println("MonitorController --> CoapClient changed ->" + stateW);
					System.out.println("_____________________Updating manager web view...");
					System.out.println("TOPIC: "+WebSocketConfig.topicForManager3+"\nTESTO: "+stateW);
					smt.convertAndSend(WebSocketConfig.topicForManager3, 
							new ResourceRepMine("" + HtmlUtils.htmlEscape(stateW)  ));
					
					WaiterUpdateResourceHandler.parseUpdate(controller, stateW);		
					
				}

				@Override
				public void onError() {
					System.out.println("MonitorController --> CoapClient error!");
				}
			});
	    	connQakSupportB.getClient().observe(new CoapHandler() {
				@Override
				public void onLoad(CoapResponse response) {
					stateB = response.getResponseText();
					System.out.println("MonitorController --> CoapClient changed ->" + stateB);
					System.out.println("_____________________Updating manager web view...");
					System.out.println("TOPIC: "+WebSocketConfig.topicForManager2+"\nTESTO: "+stateB);
					smt.convertAndSend(WebSocketConfig.topicForManager2, 
							new ResourceRepMine("" + HtmlUtils.htmlEscape(stateB)  ));
				}

				@Override
				public void onError() {
					System.out.println("MonitorController --> CoapClient error!");
				}
			});
		}
}</change_evid></code></pre>
	<p>The updating is now done by another handler capable of parsing the updateResource String. It can be found at <a href="./WaiterUpdateResourceHandler.java">WaiterUpdateResourceHandler.java</a>. Hereunder is reported a piece of its code as an example:
	<pre class="mytab"><code>public final class WaiterUpdateResourceHandler {
	
	public static void parseUpdate(ProvaController pc, String update) {
		
		if(update.contains("clientSitting")) {
			parseSit(pc,update);
		}
		else if(update.contains("clientOrdering")) {
			parseOrder(pc,update);
		}
		else if(update.contains("teaServed")) {
			parseServed(pc,update);
		}
		...
	}

	private static void parseEnter(ProvaController pc, String update) {
		String[] elem = getElements(update,":");
		System.out.println("__________Client "+elem[2]+" can enter now");
		String resp="Waiter :- Please, follow me...";
		pc.updateWaiterResp(resp, "/topic/"+elem[2]);
		
	}

	private static void parseWait(ProvaController pc, String update) {
		String[] elem = getElements(update,":");
		long temp = Long.parseLong(elem[3]);
		long minutes = temp / (1000L*60L);
		long seconds = ( temp / 1000L ) % 60L;
		System.out.println("__________Client "+elem[2]+" has to wait");
		String resp="You have to wait at maximum " + minutes +" minutes and "+seconds+" seconds. Please, come again later. We are sorry for the waiting...";
		pc.updateWaiterResp(resp, "/topic/"+elem[2]);
	}
	
	...
}</code></pre>
	<p>Again, the client-side updating is taken care by <a href="./reception.js">reception.js</a> that now listens on other three different topics, one for actor (/topic/displybarman , /topic/displytearoom , /topic/displaywaiterstate ).</p>
	<p>All the other files can be found here:
		<ul>
			<li><a href="./WebSocketConfig.java">WebSocketConfig.java</a></li>
			<li><a href="./ProvaController.java">ProvaController.java</a></li>
		</ul>
	</p>
	</div>
	<h4>Testing with client in action</h4>
	
	<center><video width="80%" controls>
		<source src="./video/threeclients.mp4" type="video/mp4">
		<source src="./video/threeclients.ogg" type="video/ogg">
		Your browser does not support the video tag.
	</video></center>
	
	<!--<h4>Automated Test Plans</h4>-->
</div>

</div>



 <!--------------------------------------------------------------------------------------------------------------------------------->

<table id="authors" border="1" align="center">
<tr>
<td style="width:50%">
<center>By Elena Martini ~ email: elena.martini6@studio.unibo.it</center> 
</td>
<td style="width:50%">
<center>By Elisa Drudi ~ email: elisa.drudi4@studio.unibo.it </center>
</td>
</tr>
<!-- ---------------->
<tr>
<td style="width:50%">
<center><img src="./mia.jpg" alt="mbot" width="50%"></center>
</td>
<td style="width:50%">
<center><img src="./img/imageProfilo.jpeg" alt="mbot" width="20%"></center>
</td>
</tr>
</table>  
</body>
</html>

<html><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><meta name="Robots" content="NOINDEX " /></head><body></body>
                <script type="text/javascript">
                 var gearPage = document.getElementById('GearPage');
                 if(null != gearPage)
                 {
                     gearPage.parentNode.removeChild(gearPage);
                     document.title = "Error";
                 }
                 </script>
</html>