<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
<!--
body
{
    margin-left:  30px;
    margin-right: 30px;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #1F37B5;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}
h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
	border-radius: 10px;
	padding: 5px;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #9ed8ff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #C0F0E0;
    font-size: 100%;
	width: 100%;
	border-radius: 5px;
	padding: 5px;
}
h5 {
    background-color: #d5ffb0;
    font-size: 90%;
	border-radius: 5px;
	padding: 3px;
	padding-top: 0;
	margin-top: 0;
	
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #154A7E;
	padding: 1px;
	border-radius: 5px;
}
ks{
	background-color: #E8FFD3;
	padding: 1px;
	padding-left: 3px;
	padding-right: 3px;
	border-radius: 5px;
	 
}
pre{
	font-family: "Consolas";
	font-size: 80%;
	background-color: #F8FFFD;
	border: 1.5px solid #90E4C8;
	padding: 10px;
	border-radius: 10px;
	overflow-x: auto;
	white-space: pre-wrap;
	white-space: -moz-pre-wrap;
	white-space: -pre-wrap;
	white-space: -o-pre-wrap;
	word-wrap: break-word;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
    font-size: 19px;
	line-height: 110%;
}    
div.cit{
	padding: 10px;
	margin: 5px;
    font-size: 18px;
	background-color: #EFF9F6;
	border-radius: 25px;
	border: 1px solid #d5f2ed;
}       
div.remark{
	background-color: #ffffff;	
    border: 1.5px solid #d5f2ed;
	padding-left: 20px;
	padding-right: 30px;
    margin: 10px;
	border-radius: 25px;
}  
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

ul{
	margin: 10px;
	margin-left: 20px;
	padding: 0;
}

li{
	padding-top: 5px;
}

table, th, td {
	border: 2px solid #d5f2ed;
}
td{
	padding: 10px;
}

#authors {
	width: 600px;
	border: 2px solid #AB55FF;
}

#authors td {
    background-color: #b2c0ff;
	padding: 10px;
	border: 2px solid #AB55FF;
}
i{
	font-weight: bold;
}
tl, ttr{
	color: #154A7E;
	font-weight: bold;
}
ttr{
	font-style: italic;
}
.mytab{
	tab-size: 4;
}
keyw{
	color: #B12283;
	font-weight: bold;
}
comm{
	color: #00BD06;
}
strs{
	color: #145CDE;
}
ints{
	color: #E7BE41;
	}
p.did{
	margin: 0;
	padding-bottom: 10px;
	padding-top: 0;
	padding-left: 15px;
	padding-right: 5px;
	font-size: 18px;
	border-left: 2px dashed silver;
}
sevid{
	background-color: #A8ECC7;
	border-radius: 5px;
	padding: 2px;
}
tevid{
	border-radius: 5px;
	padding: 2px;
	border: 2px solid #A8ECC7;
	line-height: 24px;
}
mevid{
	background-color: #D4F7E4;
}
change_evid{
	background-color: #FFFF99;
	border-radius: 5px;
	padding: 2px;
}
schange_evid{
	background-color: #FFE699;
	border-radius: 5px;
	padding: 2px;
}
tchange_evid{
	border-radius: 5px;
	padding: 2px;
	border: 2px solid #FFE699;
	line-height: 24px;
}
video{
	margin: 30px;
}

change1{
	background-color: #FFFF99;
	border-radius: 5px;
	padding: 2px;
}

change2 {
	background-color: #FFB900;
	border-radius: 5px;
	padding: 2px;
}
 
change3 {
	background-color: #FF9999;
	border-radius: 5px;
	padding: 2px;
}
  -->
</style>
    
<head>
   
<title>Tearoom - sprint 4</title></head>
    
<body>
<div id="top">
<h1>Safe Tearoom COVID-19<font size="5"></font> </h1>
</div>  

<div class="body"> 

<!--<h2>Introduction</h2>
<div class="remark">
</div>-->

<h2>Specifics</h2>
<div class="remark">
	<h4>Introduction</h4>
	<p>At the end of the third Sprint the team was able to complete the development of the system as per customer requirements. However, the need to make some changes to our system subsequently emerged. This need arose from considerations that emerged during further internal team meetings, born in part from more in-depth tests carried out on the system and in part from the experience gained by the team during the previous sprints.</p>
	<p>In the following paragraphs, the updates performed on the system are briefly explained. More details about the components implementation will be given in the <i>Project</i> section of this document.</p>
	<h4>Updates</h4>
	<ul>
		<li>
			<h5>Optimized clean table interruption</h5>
			<p><i>Need</i> : After more in-depth tests carried out on the system, the team found out that after the waiter was interrupted while cleaning, even if there are more than one prioritized tasks in the queue, it won't perform all of them before returning to clean, but after the first task, it will return to the teatable just to interrupt the cleaning action immediately after to perform another prioritized task (and so on). This behavior is not wrong, but is extremely inefficient in terms of time, time that is wasted in the moving action between key points (for the prioritized tasks) and the table to clean.</p>
			
			<p><i>Solution</i> : before deciding if he can return to clean, it checks for other prioritized tasks in the queue and, if at least one is present, it performs them. Just after that it will return to cleaning action.</p>
		</li>
		<li>
			<h5>Simultaneous messages handling</h5>
			<p><i>Need</i> : Some more in-depth tests have highlighted an inaccuracy in the handling, by Waiter and Mastertimer, of some specific sequences of messages that can occur if two system components send these messages almost simultaneously. In particular, below are summarized the sequences of problematic messages for the Waiter and the Mastertimer (more detail will be given in their qak models).
				<ul>
					<li><u>Mastertimer</u>: it may happen that the Waiter and a Subtimer simultaneously send respectively a <em>stopTimer / endTimer</em> and a <em>timeoutSubtimer</em> for the same teatable. When this happens it is necessary that the Mastertimer manages the second message arrived taking into account the message arrived immediately before because if the Subtimer has already expired it would not make sense to perform either the stopSubtimer operation or the endSubtimer operation on it;</li>
					<li><u>Waiter</u>: it may happen that the Client and the Subtimer simultaneously send respectively a <em>wantToOrder / billPlease</em> and a <em>timeout</em> for the same teatable. When this happens it is necessary for the Waiter to handle the second message arrived taking into account the message that arrived immediately before as if a Client has already been accompanied out of the tearoom, it makes no sense to process other messages relating to him.</li>
				</ul>
			</p>
			<p><i>Solution</i> : In both cases it is necessary that Mastertimer and Waiter respectively remember that they have already fully managed a particular Subtimer or a particular customer so that further messages that require other operations on them are discarded.</p>
		</li>
		<li>
			<h5>Testing with client</h5>
			<p><i>Need</i> : after performing more in-depth tests on the system, the need arose for a way to display, other than the client GUI that lets us interact with the waiter, information on the waiter activities, so that we can better control its behaviour.
			</p>
			<p><i>Solution</i> : as the manager already diplayed the waiter activity (through its states), we had just to add those funtionalities (manager ones) to the client GUI.
			</p>
		</li>
		<li>
			<h5>Observing the waiter to change</h5>
			<p><i>Need</i> : The events that the waiter was sending to the client were introduced to let the mock client know where the waiter was (i.e. if the client had requested the bill and the waiter reached the teatable, so the waiter sends an event to inform the client about its presence) so that the client GUI could change and show new elements of interaction. Though, the system will have to deal with real clients (in person), so the events that were listened by the GUI will then be sent uselessly. 
			</p>
			<p><i>Solution </i>: the waiter doesn't need any more to send events to make his position know by others, but it is possible to know its state thorugh the state mechanism. The client GUI will just observe the waiter status and change the web-view at every update of it.
			</p>
		</li>
	</ul>
</div>

<h2>Project</h2>
<div class="remark">
	<h4>Structure</h4>
	<div>
		<ul>
			<li><h5>Logical Architecture</h5>
				<p>@TONNO perché non ci sono più eventi </p>
				<center><img src="img/prog_architecture.PNG" alt="logical architecture" width="100%"/></center>		
			</li>
			</br>
			<li>
				<h5>Manager architecture</h5>
				The Manager architecture remained unchanged and is summarized in the image below.  
				</br></br>
				<center><img src="img/proj_manager.png" alt="logical architecture" width="70%"/></center>
			</li></br>
			<li>
				<h5>Waiter architecture</h5>
				
				The Waiter architecture has not changed compared to what was defined in the @TONNO<a href="https://htmlpreview.github.io/?https://github.com/gitemar/Martini_Drudi_Safe_Tearoom/blob/master/week_2_step_1/userDocs/Progetto_Martini_Drudi.html">Sprint 1 project document</a>.
			</li>
		</ul>
	</div>
	<h4>Interaction</h4>
	<div>
		<p> No new form of interaction has been introduced in this fourth sprint, therefore what was discussed in all the previous Sprints, is still valid.</p>
	</div>
	<h4>Behaviour</h4>
	<div>
	<p>Compared to the previous Sprints, the waiter actor and mastertimer actor have undergone some optimization changes (as described in the "Updates" - section). Hereunder, their QAK models are reported and the changes highlighted. 
	</br>Changes related to the <u>simultaneous message handling need</u> are highlighted in <change3>pink</change3> , those related to the <u>optimized clean table interruption</u> need are highlighted in <change2>orange</change2> and those reletad to <u>the observing the waiter to change need</u> are highlighted in <change1>yellow</change1></p>
		<ul>
			<li><h5>Mastertimer QAK behaviour</h5>
				<pre class="mytab"><code><keyw>System</keyw> waiter
			
<keyw>mqttBroker</keyw> <strs>"localhost"</strs> : <ints>1883</ints> <keyw>eventTopic</keyw> "unibo/polar" 	<comm>//mqtt.eclipse.org</comm>

<comm>// Interaction Mastertimer - Waiter =================================//</comm>
<keyw>Dispatch</keyw> startTimer 	: startTimer(TEATABLE_ID, MAX_TIME)	   
<keyw>Dispatch</keyw> stopTimer 	: stopTimer(TEATABLE_ID)			   
<keyw>Dispatch</keyw> resumeTimer 	: resumeTimer(TEATABLE_ID)			   
<keyw>Dispatch</keyw> endTimer 		: endTimer(TEATABLE_ID)				   
<keyw>Dispatch</keyw> timeout 		: timeout(TEATABLE_ID)				   
<comm>//=============================================================//</comm>

<comm>// Interaction MasterTimer - SubTimers =========================//</comm>
<keyw>Dispatch</keyw> startSubtimer 		: startSubtimer(MAX_TIME)
<keyw>Dispatch</keyw> stopSubtimer 		: stopSubtimer(ARG)
<keyw>Dispatch</keyw> resumeSubtimer 	: resumeSubtimer(ARG)
<keyw>Dispatch</keyw> endSubtimer 		: endSubtimer(ARG)
<keyw>Dispatch</keyw> timeoutSubtimer 	: timeoutSubtimer(TEATABLE_ID)
<comm>//==============================================================//</comm></code></pre>
				<p><i>Simultaneous messages handling</i>: Regarding the Simultaneous messages handling need, it may happen that, as already mentioned above, the Mastertimer has a timeoutSubtimer and a stopTimer / endTimer related to the same teatable in the message queue. This happens when Subtimer and Waiter send these messages at the same time. There are four possible cases that need to be kept in consideration:
					<ol>
						<li>
							<p>Inside the queue of the Mastertimer there is first a <u>timeoutSubtimer</u> message and then a <u>stopTimer</u> message for the same teatable.</p>
							<p><i>Solution</i> : The Mastertimer handles as usual the timeoutSubtimer by notifying the Waiter, but also remembers that the timer for that teatable has expired (it will forget this information the next time it receives StartTimer for that teatable). When it's time to handle the stopTimer, it remembers that the timer has already expired and therefore discards the message.</p>
						</li>
						<li>
							<p>Inside the queue of the Mastertimer there is first a <u>stopTimer</u> message and then a <u>timeoutSubtimer</u> message for the same teatable.</p>
							<p><i>Solution</i> : The Mastertimer handles as usual the stopTimer message by notifying the correct Subtimer. The Subtimer will ignore this message because, having finished counting, it expects a message of type startSubtimer (discardMsg On). Afterwards, the Mastertimer handle the timoutSubtimer normally by notifying the Waiter. Therefore, it will be up to the Waiter to correctly handle the timeout after a StopTimer.</p>
						</li>
						<li>
							<p>Inside the queue of the Mastertimer there is first a <u>timeoutSubtimer</u> message and then a <u>endTimer</u> message for the same teatable.</p>
							<p><i>Solution</i> : The Mastertimer handles as usual the timeoutSubtimer message by notifying the Waiter, but also remembers that the timer for that teatable has expired (this information will be forgotten the next time a StartTimer message is received for that teatable). When it's time to handle the endTimer message, the Mastertimer remembers that the timer has already expired and therefore discards the message.</p>
						</li>
						<li>
							<p>Inside the queue of the Mastertimer there is first a <u>endTimer</u> message and then a <u>timeoutSubtimer</u> message for the same teatable.</p>
							<p><i>Solution</i> : The Mastertimer handles as usual the endTimer message by notifying the Waiter and remembers that the timer for that teatable was 'ended'(this information will be forgotten the next time a StartTimer message is received for that teatable). Since the Subtimer has already finished counting it expects a startSubtimer message, thus it will ignore the message endSubtimer sent by the Mastertimer (discardMsg On). Subsequently, when the Mastertimer handle the timoutSubtimer message, it remembers that the timer was already 'ended', meaning that the Waiter is no longer interested in receiving a timeout for that table and thus it will discard the message. </p>
						</li>
					</ol>
				</p>
				<pre class="mytab"><code><sevid>QActor mastertimer</sevid> context ctxwaiter {
	
	[#
		val map = mutableMapOf<Int, ActorBasic?>()
		var Teatable : Int
		
		<change3>val endedTimers = mutableMapOf<Int, Boolean?>()</change3>
	#]
	
	<sevid>State s0 initial</sevid> {
		discardMsg Off
		
		[#
			//map init: create timer to be immediately ready when Waiter want to use timers
			map.put(1, Subtimer("subtimer1", scope, context!!, 1))
			map.put(2, Subtimer("subtimer2", scope, context!!, 2))

			<change3>endedTimers.put(1, false)</change3>
			<change3>endedTimers.put(2, false)</change3>
			
			// waiting for subtimer to be created
			delay(1000)
		#]
	}
	<tevid>Goto waitForCommand</tevid>
	
	<sevid>State waitForCommand</sevid>{
		println("mastertimer | waiting for waiter's command...")
	}
	<tevid>Transition t0 	whenMsg startTimer -> startTimer</tevid>
					<tevid>whenMsg stopTimer -> stopTimer</tevid>
					<tevid>whenMsg resumeTimer -> resumeTimer</tevid>
					<tevid>whenMsg endTimer -> endTimer</tevid>
					<tevid>whenMsg timeoutSubtimer -> handleTimeout</tevid>
	
	<sevid>State startTimer</sevid> {
		onMsg(startTimer : startTimer(TABLE, TIME)){
			println("mastertimer | starting timer for teatable ${payloadArg(0)} and timeout ${payloadArg(1)} ms")
		    [#
		    	Teatable = payloadArg(0).toInt()
		    	<change3>endedTimers.put(Teatable, false)  //forget past end for simulaneus timeout/endTimer message handling</change3>
		    	forward("startSubtimer", "startSubtimer(${payloadArg(1)})" ,"${map.get(Teatable)!!.name}" )
		    #]

		}
		
	}
	<tevid>Goto waitForCommand</tevid>
	
	<sevid>State stopTimer</sevid>{
		onMsg(stopTimer : stopTimer(TABLE)) {
			
			 println("mastertimer | stopping timer for teatable ${payloadArg(0)}...")
			 [# Teatable = payloadArg(0).toInt()#]
			
			<change3>if [# endedTimers.get(Teatable)!! == true #] { //warning: simultaneously received stopTimer and timeout</change3>
					<change3>println("mastertimer | [stopTimer] ignoring message already handled...")</change3>
					//ignore message
			<change3>}</change3>
			else{
					println("mastertimer | stopping timer for teatable ${payloadArg(0)}...")
					[# forward("stopSubtimer", "stopSubtimer(arg)" ,"${map.get(Teatable)!!.name}" ) #]
					
			}

		}
	}
	<tevid>Goto waitForCommand</tevid>
	
	<sevid>State resumeTimer</sevid> {
		onMsg(resumeTimer : resumeTimer(TABLE)) {
			
			 println("mastertimer | resuming timer for teatable ${payloadArg(0)}...")
			 [#
		    	Teatable = payloadArg(0).toInt()
		    	forward("resumeSubtimer", "resumeSubtimer(arg)" ,"${map.get(Teatable)!!.name}" )
		    #]

		}
	}
	<tevid>Goto waitForCommand</tevid>
	
	<sevid>State endTimer</sevid> {
		onMsg(endTimer : endTimer(TABLE)) {
			
			 println("mastertimer | ending timer for teatable ${payloadArg(0)}...")
			  [# Teatable = payloadArg(0).toInt()#]
			
			<change3>if [# endedTimers.get(Teatable)!! == true #] { //warning: simultaneously received endTimer and timeout</change3>
					<change3>println("mastertimer | [endTimer] ignoring message already handled...")</change3>
					//ignore message
			<change3>}</change3>
			else{
					println("mastertimer | ending timer for teatable ${payloadArg(0)}...")
					[# forward("endSubtimer", "endSubtimer(arg)" ,"${map.get(Teatable)!!.name}" ) #]
					[# endedTimers.put(Teatable, true) #] //remember past end for simultaneous timeout/endTimer message handling 
			}

		}
	}
	<tevid>Goto waitForCommand</tevid>
	
	<sevid>State handleTimeout</sevid> {
		onMsg(timeoutSubtimer : timeoutSubtimer(TABLE)){
			[# Teatable = payloadArg(0).toInt()#]
			
			<change3>if [# endedTimers.get(Teatable)!! == true #] { //warning: simultaneously received endTimer/stopTimer and timeout</change3>
					<change3>println("mastertimer | [timeoutSubtimer] ignoring message already handled...")</change3>
					//ignore message
			<change3>}</change3>
			else{
				println("mastertimer | timeout for teatable $Teatable...")
				forward waiter -m timeout : timeout($Teatable)
				[#	endedTimers.put(Teatable, true) #] //remember past end for simultaneous timeout/endTimer/stopTimer message handling 
			}
		} 
	}
	<tevid>Goto waitForCommand</tevid>
}</code></pre>
			</li>
			<li><h5>Waiter QAK behaviour</h5>
			<pre class="mytab"><code><keyw>System</keyw> waiter
			
<keyw>mqttBroker</keyw> <strs>"localhost"</strs> : <ints>1883</ints> <keyw>eventTopic</keyw> "unibo/polar" 	<comm>//mqtt.eclipse.org</comm>

<comm>// Interaction Waiter - Mover =================================//</comm>
<keyw>Request</keyw> moveTo 	: moveTo(KEY_POSITION)						   
<keyw>Reply</keyw> done 		: done(X,Y)									   
<keyw>Dispatch</keyw> end 	: end(ARG)									  
<comm>//=============================================================//</comm>

<comm>// Interaction Waiter - MasterTimer =================================//</comm>
<keyw>Dispatch</keyw> startTimer 	: startTimer(TEATABLE_ID, MAX_TIME)	   
<keyw>Dispatch</keyw> stopTimer 	: stopTimer(TEATABLE_ID)			   
<keyw>Dispatch</keyw> resumeTimer 	: resumeTimer(TEATABLE_ID)			   
<keyw>Dispatch</keyw> endTimer 		: endTimer(TEATABLE_ID)				   
<keyw>Dispatch</keyw> timeout 		: timeout(TEATABLE_ID)				   
<comm>//=============================================================//</comm>

<comm>// Interaction Waiter - Tearoom ========================================//</comm>
<keyw>Request</keyw> getRoomState : getRoomState(REQUEST, ARG1)						
<keyw>Reply</keyw> state : state(STATE)
<keyw>Reply</keyw> numBusyAndDirty : numBusyAndDirty(BUSY,DIRTY)
<keyw>Dispatch</keyw> updateState : updateState (UPDATE_REQUEST, ARG1, ARG2, ARG3)	
<comm>//======================================================================//</comm>

<comm>// Interaction Waiter - Smartbell ============================//</comm>
<keyw>Dispatch</keyw> enter : enter(CLIENT_ID)						      
<comm>//============================================================//</comm>

<comm>// Interaction Waiter - Client ===============================//</comm>
<keyw>Dispatch</keyw> wantToOrder	: wantToOrder(TEATABLE_ID)	          	  
<keyw>Dispatch</keyw> tea 			: tea(TEATABLE_ID, TEA)				    
<keyw>Dispatch</keyw> billPlease 	: billPlease(TABLE_ID)			  
<comm>//============================================================//</comm>

<comm>// Interaction Waiter - Barman  ==============================//</comm>
<keyw>Dispatch</keyw> order : order(TEATABLE_ID, TEA)					  
<keyw>Dispatch</keyw> ready : ready(TEATABLE_ID,TEA)						  
<comm>//============================================================//</comm>

<comm>// Interaction Waiter auto-message ===========================//</comm>
<keyw>Dispatch</keyw> cleanTable : cleanTable (TEATABLE_ID)				  
<comm>//============================================================//</comm></code></pre>
		
		<p><i>Optimized clean table interruption</i> : as mentioned above (Updates section), before returning to the cleaning action after it was interrupted, the waiter checks if there are any prioritized tasks (state <u>checkForOtherPrioritizedTasks</u>). If there are, it performs them.</p>
		
		<p><i>Simultaneous messages handling</i> : regarding the simultaneous messages handling need, it may happen that, as already mentioned above, the Waiter has a wantToOrder/ billPlease and a timeout reletad to the same teatable in its message queue.This happens when Client and Mastertimer send these messages at the same time.There are four possible cases that need to be kept in consideration:
			<ol>
				<li>
					<p>Inside the queue of the Waiter there is first a <u>timeout</u> message and then a <u>wantToOrder</u> message for the same teatable (within the safe tearoom each customer is univocally associated with a teatable).</p>
					<p><i>Solution</i> : The Waiter handle as usual the tiemout message by notifying the Client and helping him to leave the tearoom. The Waiter also remembers that the customer at that teatable has already been fully managed (this information will be forgotten the next time it assigns the teatable to a new customer). Subsequently, when it's time to handle the WantTOrder message, the Waiter remembers that the customer is no more inside the tearoom and will discard the message.</p>
				</li>
				<li>
					<p>Inside the queue of the Waiter there is first a <u>wantToOrder</u> message and then a <u>timeout</u> message for the same teatable.</p>
					<p><i>Solution</i> : The Waiter handle as usual the wantToOrder message by taking the customer's order and asking the Barman to prepare it. The Waiter then normally handle the timeout message by making the customer pay and escorting him to the exit door. It also remembers that the customer at that teatable is no more inside the tearoom (this information will be forgotten the next time it assigns the teatable to a new customer). When the Waiter handle the ready message sent from the Barman for that teatable, it remembers that the order is for a client that has already left the tearoom and thus discards the message.</p>
				</li>
				<li>
					<p>Inside the queue of the Waiter there is first a <u>timeout</u> message and then a <u>billPlease</u> message for the same teatable.</p>
					<p><i>Solution</i> : The Waiter handle as usual the timeout message by notifying the Client and helping him to leave the tearoom. The Waiter also remembers that the customer at that teatable has already been fully managed (this information will be forgotten the next time it assigns the teatable to a new customer). Subsequently, when it's time to handle the billPlease message, the Waiter remembers that the customer is no more inside the tearoom and will discard the message.</p>
				</li>
				<li>
					<p>Inside the queue of the Waiter there is first a <u>billPlease</u> message and then a <u>timeout</u> message for the same teatable.</p>
					<p><i>Solution</i> : The Waiter handle as usual the billPlease message by making the customer pay and then escorting him to the exit. The Waiter also remembers that the customer at that teatable has already been fully managed (this information will be forgotten the next time it assigns the teatable to a new customer). Subsequently, when it's time to handle the timeout message, the Waiter remembers that the customer is no more inside the tearoom and will discard the message.</p>
				</li>
			</ol>
		</p>
		
		<pre class="mytab"><code>Context ctxwaiter 		 	ip [host="127.0.0.1" port=8029]
Context ctxtearoom 		 	ip [host="localhost" port=8015]

ExternalQActor tearoom 		context ctxtearoom
ExternalQActor barman		context ctxtearoom
ExternalQActor smartbell	context ctxtearoom

CodedQActor datacleaner    	context ctxwaiter className "rx.dataCleaner"
CodedQActor distancefilter 	context ctxwaiter className "rx.distanceFilter"
CodedQActor basicrobot 		context ctxwaiter className "it.unibo.basicrobot.Basicrobot"
CodedQActor trustingwalker 	context ctxwaiter className "it.unibo.trustingwalker.Trustingwalker"



<sevid>QActor waiter</sevid> context ctxwaiter {
	
	[# 
		var MaxWaitTime = 0L
		val MaxStayTime = 20000L   	// 1min
		val IdleTime = 200L	
		val MaxCleanTime = 5000L			// 200 ms
		
		var ClientToConvoy = ""
		var DestTable = -1
		var CurDrink = ""
		var Price = 3
		
		var TimeToClean = MaxCleanTime
		var TimeCleanBegan = 0L
		var WasCleaning = false
		var TableToClean = 0
		
		<change3>val stopHandlingClientAtTable = mutableMapOf<Int, Boolean?>()</change3>
		var stopCheck = false
	#]
	
	
	<sevid>State s0 initial</sevid> {
		
		//init
		println("waiter | beep beep boop...START...")
		<change3>[# stopHandlingClientAtTable.put(1, false) #]</change3>
		<change3>[# stopHandlingClientAtTable.put(2, false) #]</change3>
		discardMsg Off
	}
	<tevid>Goto restingAtHome</tevid>
	
	// WAITER WAIT FOR TASK TO DO 1
	<sevid>State restingAtHome</sevid> {
			
		println("waiter | Chilling out at home...")	
		updateResource[#"atPosition(0,0,home)"#]
		
	}
	<tevid>Transition t0 	whenMsg enter -> handleEnterPhase1</tevid>
					<tevid>whenMsg wantToOrder -> handleOrderFromClientPhase0</tevid>
					<tevid>whenMsg ready -> serveTeaToClientPhase0</tevid>
					<tevid>whenMsg timeout -> handleTimeoutPhase0</tevid>
					<tevid>whenMsg billPlease -> handlePaymentPhase0 </tevid>
					<tevid>whenMsg cleanTable -> cleanTeatablePhase1</tevid>
	
	// WAITER WAIT FOR TASK TO DO 2
	<sevid>State doATask</sevid> {
		
		println("waiter | checking if there is a task to do...")
		
	}
	<tevid>Transition t0 	whenTimeVar IdleTime -> goHome</tevid>			
					<tevid>whenMsg enter -> handleEnterPhase1</tevid>
					<tevid>whenMsg wantToOrder -> handleOrderFromClientPhase0</tevid>
					<tevid>whenMsg ready -> serveTeaToClientPhase0</tevid>
					<tevid>whenMsg timeout -> handleTimeoutPhase0</tevid>
					<tevid>whenMsg billPlease -> handlePaymentPhase0 </tevid>
					<tevid>whenMsg cleanTable -> cleanTeatablePhase1</tevid>
	
	// WAITER GO HOME
	<sevid>State goHome</sevid> {
		
		updateResource[#"goingHome"#]
		request mover -m moveTo : moveTo(home)
		
	}
	<tevid>Transition t0 whenReply done -> restingAtHome</tevid>


	<comm>/******************  WAITER HANDLE ENTER REQUEST ********************************************************************/</comm>
	
	<sevid>State handleEnterPhase1</sevid> {
		println("waiter | enter message arrived")
		onMsg(enter : enter(CLIENT_ID)){
			if [# WasCleaning == true #]{
				[# var TempTime = 0L #]
				memoCurrentTime TempTime
				[# TimeToClean = TimeToClean - (TempTime - TimeCleanBegan) #]
				println("waiter | interrupted cleaning to handle enter request")
			}
			[#ClientToConvoy = payloadArg(0)#]
			println("waiter | a client with client_id ${payloadArg(0)} asked to enter the safe tearoom...")
			println("waiter | checking if the safe tearoom has a free table ...")
			request tearoom -m getRoomState : getRoomState(getFreeTable, arg1)
		} //onMsg
		
	}
	<tevid>Transition t0 whenReply state -> handleEnterPhase2</tevid>
	
	<sevid>State handleEnterPhase2</sevid> {
		println("waiter | state response arrived")
		onMsg(state : state(S)){
			if [#payloadArg(0).toInt() == 0 #] { //NO free and clean table (CAN'T HAPPEN in this first prototype since there is only one client)
				[#MaxWaitTime = 1L#]
				println("waiter | But there is no free and clean teatable")
			}
			else { // there is a free and clean table and Tearoom sent me it's ID
				[# 
					MaxWaitTime =  0L
					DestTable = payloadArg(0).toInt()
				#]
			}
		}
		println("waiter | waittime: $MaxWaitTime")
	}
	<tevid>Goto convoyClientToTablePhase1 if [# MaxWaitTime == 0L #] else requestTableStates</tevid>
	
	<sevid>State requestTableStates</sevid>{
		println("waiter | requesting teatable states to tearoom...")
		request tearoom -m getRoomState : getRoomState(getBusyAndDirtyTables, arg1)
	}
	<tevid>Transition t0 whenReply numBusyAndDirty -> analyzeTableStates</tevid>
	
	<sevid>State analyzeTableStates</sevid>{
		onMsg(numBusyAndDirty : numBusyAndDirty(B,D)){
			println("waiter | tearoom replied with ${payloadArg(0)}-${payloadArg(1)} (busy-dirty)")
			[#
				val b=payloadArg(0).toInt()
				val d=payloadArg(1).toInt()
				var totTime = 0L
				if(d>0){
					totTime = MaxCleanTime
				}
				else{
					totTime = MaxStayTime
				}
				MaxWaitTime = totTime
			#]
			println("waiter | client has to wait at least $MaxWaitTime minutes")
			<change1>updateResource[#"newClient($ClientToConvoy):clientWaiting:$ClientToConvoy:$MaxWaitTime"#]</change1>
			delay 800
		}
	}
	<change2>Goto doATask if [# WasCleaning == false #] else checkForOtherPrioritizedTasks</change2>
	
	
	
	<comm>/*************  WAITER CONVOY CLIENT TO TABLE *************************************************************************/</comm>
	
	<sevid>State convoyClientToTablePhase1</sevid> {
		<change1>updateResource[#"reachingPosition(entrance)"#]</change1>
		println("waiter | reaching entrance door to convoy client $ClientToConvoy to teatable $DestTable ...")
		request mover -m moveTo : moveTo(entrance)
	}
	<tevid>Transition t0 whenReply done -> convoyClientToTablePhase2</tevid>
	
	<sevid>State convoyClientToTablePhase2</sevid> {
		onMsg(done : done(X,Y)){
			<change1>updateResource[#"atPosition(entrance,${payloadArg(0)},${payloadArg(1)}):clientEntering:$ClientToConvoy:$MaxWaitTime"#]</change1>
			delay 500
			<change1>updateResource[#"convoyingClientToTable($DestTable,$ClientToConvoy)"#]</change1>
			println("waiter | convoying client $ClientToConvoy to teatable $DestTable ...")
			[#var Dest =  "teatable" + DestTable.toString() #]
			request mover -m moveTo : moveTo($Dest)
		}
	}
	<tevid>Transition t0 whenReply done -> convoyClientToTablePhase3</tevid>
		
	<sevid>State convoyClientToTablePhase3</sevid> {
		onMsg(done : done(X,Y)){
			println("waiter | Start mastertimer, update tearoom and telling client to sit")
			forward tearoom -m updateState : updateState (updateTableState, $DestTable, busy, $ClientToConvoy)
			<change1>updateResource[# "atPosition(teatable$DestTable,${payloadArg(0)},${payloadArg(1)}):clientSitting:$ClientToConvoy:$DestTable" #]</change1>
			//refresh information in stopHandlingClientAtTable to correctly handle case of simultaneous timeout/billPlease/wantToOrder
			[# stopHandlingClientAtTable.put(DestTable, false) #]
			//start timer to count until MaxStayTime
			delay 500
			forward mastertimer -m startTimer : startTimer($DestTable, $MaxStayTime)
		}
		
	}
	<change2>Goto doATask if [# WasCleaning == false #] else checkForOtherPrioritizedTasks</change2>
	
	<comm>/****************************************************************************************************/</comm>
	
	<comm>/**************************************  WAITER CLEAN TABLE **************************************/</comm>
	
	<sevid>State cleanTeatablePhase1</sevid> {
		
		[# var Dest="" #]
		
		onMsg(cleanTable : cleanTable(T)) {
			println("Waiter moving towards teatable to clean (${payloadArg(0)})")
			[#
			  Dest =  "teatable" + payloadArg(0) 
			  DestTable = payloadArg(0).toInt()
			  TableToClean = payloadArg(0).toInt()
			#]
		}
		
		//resuming cleaning if waiter was cleaning
		if[# WasCleaning == true #]{
			println("Waiter moving towards teable $TableToClean to resume cleaning")
			[#
			  Dest =  "teatable" + TableToClean
			  DestTable = TableToClean
			#]
		}
		
		<change1>updateResource[#"cleaning($DestTable)"#]</change1>
		//first we reach the table
		request mover -m moveTo : moveTo($Dest)
	}
	<tevid>Transition t0 whenReply done -> cleanTeatablePhase2</tevid>
	
	
	<sevid>State cleanTeatablePhase2</sevid> {
		
		// then we clean the teatable
		println("waiter | cleaning teatable $TableToClean")
		[#
			WasCleaning = true
		#]	
		memoCurrentTime TimeCleanBegan
	}
	<tevid>Transition t1 whenTimeVar TimeToClean -> finishedClean</tevid>
				 <tevid> whenMsg ready -> serveTeaToClientPhase0</tevid>
				 <tevid> whenMsg enter -> handleEnterPhase1</tevid>
				  <tevid>whenMsg wantToOrder -> handleOrderFromClientPhase0</tevid>
				  <tevid>whenMsg billPlease -> handlePaymentPhase0</tevid>
				  
	<sevid>State finishedClean</sevid>{
		
		println("waiter | finished cleaning teatable $TableToClean")
		//update teatable state
		forward tearoom -m updateState : updateState (updateTableState, $TableToClean, clean, ARG3)
		[# 
			WasCleaning = false
			TimeToClean = 2000L
			TableToClean = 0
			TimeCleanBegan = 0L
		#]
	}
	<tevid>Goto doATask</tevid>
	
	<change2>State checkForOtherPrioritizedTasks{</change2>
		//checking if there are other tasks that are prioritized (that would interrupt cleaning action)
		//if there is one, the waiter does that task
		//this way it won't return to the table to start cleaning and interrupt immediately after
	}
	<change2>Transition t0 whenTimeVar IdleTime -> cleanTeatablePhase1</change2>
				  <change2>whenMsg ready -> serveTeaToClientPhase1</change2>
				  <change2>whenMsg enter -> handleEnterPhase1</change2>
				  <change2>whenMsg wantToOrder -> handleOrderFromClientPhase1</change2>
				  <change2>whenMsg billPlease -> handlePaymentPhase1</change2>
				  
	<sevid>State checkIfWasCleaning</sevid>{
		//
	}
	<tevid>Goto cleanTeatablePhase1 if [# WasCleaning == true #] else doATask</tevid>
	
		
	<comm>/****************************************************************************************************/</comm>
	
	<comm>/**************************************  WAITER TAKE CLIENT's ORDER **************************************/</comm>	
		
	
	<change3>State handleOrderFromClientPhase0</change3>{
		onMsg(wantToOrder : wantToOrder(TEATABLE_ID)){
			
			if [# WasCleaning == true #]{
				[# var TempTime = 0L #]
				memoCurrentTime TempTime
				[# TimeToClean = TimeToClean - (TempTime - TimeCleanBegan) #]
				println("waiter | interrupted cleaning to handle order request")
			}
			
			[# var Teatable = payloadArg(0).toInt() #]
			
			//Was wantToOrder sent after a timeout for that client was triggered?
			if [# stopHandlingClientAtTable.get(Teatable)!! == true #] { 
					println("waiter | ignoring wantToOrder message for table $Teatable since it's client timed-out...")
					[# stopCheck = true #]
					//ignore message
			}
			else{
					//Stop timer: stop counting for orderTime now!
					forward mastertimer -m stopTimer : stopTimer($payloadArg(0))
					println("waiter | client at teatable $Teatable want to order! Reaching table $Teatable...")
					
					[# stopCheck = false #]
					//NOTE: in this case there is no need to change stopHandlingClientAtTable value! Only timeout or billplease must change it
					//memorizing teatable_id for next phase
					[#
						DestTable = Teatable
					#]
			}
		}
	}
	<change3>Goto handleOrderFromClientPhase1 if [# stopCheck == false #] else checkIfWasCleaning</change3>
	
	<sevid>State handleOrderFromClientPhase1</sevid> {
			[#
				var Dest =  "teatable" + DestTable
			#]
			<change1>updateResource[#"reachingPosition(teatable$DestTable)"#]</change1>
			request mover -m moveTo : moveTo($Dest)
	}
	<tevid>Transition t0 whenReply done -> handleOrderFromClientPhase2</tevid>
	
	<sevid>State handleOrderFromClientPhase2</sevid> {
		onMsg(done : done(X,Y)){
			println("waiter | client can now order...")
			<change1>updateResource[# "atPosition(teatable$DestTable,${payloadArg(0)},${payloadArg(1)}):clientOrdering:$DestTable" #]</change1>
	//		emit orderPlease : orderPlease($DestTable)
		}
	}
	<tevid>Transition t0 whenMsg tea -> handleOrderFromClientPhase3</tevid>
	
	<sevid>State handleOrderFromClientPhase3 </sevid>{
		
		onMsg(tea : tea(TABLE,TEA)){
			println("waiter | client at teatable ${payloadArg(0)} ordered a ${payloadArg(1)}! Sending order to Barman...")
			forward barman -m  order : order($payloadArg(0), $payloadArg(1))
		}
		
	}
	<change2>Goto checkForOtherPrioritizedTasks if [# WasCleaning == true #] else doATask</change2>
	
	
	<comm>/****************************************************************************************************/</comm>
	
	<comm>/**************************************  WAITER SERVE CLIENT  **************************************/</comm>
	
	<change3>State serveTeaToClientPhase0</change3> {
		onMsg(ready : ready(T,D)){
			
			if [# WasCleaning == true #]{
				[# var TempTime = 0L #]
				memoCurrentTime TempTime
				[# TimeToClean = TimeToClean - (TempTime - TimeCleanBegan) #]
				println("waiter | interrupted cleaning to serve")
			}
			
			[# var Teatable = payloadArg(0).toInt() #]
			
			//Was wantToOrder sent just before a timeout for that client was triggered? Then this client is no more inside the tearoom and waiter should ignore
			// this message
			if [# stopHandlingClientAtTable.get(Teatable)!! == true #] { 
					println("waiter | ignoring ready message for table $Teatable since it's client is no more inside the tearoom...")
					[# stopCheck = true #]
					//ignore message
			}
			else{
					[# stopCheck = false #]
					
					//memorizing some information for next phase
					[#
						DestTable = Teatable
						CurDrink = payloadArg(1)
					#]
			}
			
		}
	}
	<change3>Goto serveTeaToClientPhase1 if [# stopCheck == false #] else checkIfWasCleaning</change3>
	
	<sevid>State serveTeaToClientPhase1</sevid> {
		<change1>updateResource[#"reachingPosition(servicedesk)"#]</change1>
		println("waiter | order for table $DestTable ready! Reaching service desk...")
		request mover -m moveTo : moveTo(servicedesk)
				
	}
	<tevid>Transition t0 whenReply done -> servTeaToClientPhase2</tevid>
	
	<sevid>State servTeaToClientPhase2</sevid> {
		
		onMsg(done : done(X,Y)){
			<change1>updateResource[#"atPosition(servicedesk,${payloadArg(0)},${payloadArg(1)}):tea($CurDrink,$DestTable)"#]</change1>
			delay 500
			println("waiter | bringing tea to table $DestTable...")
			[#var Dest =  "teatable" + DestTable #]
			<change1>updateResource[#"reachingPosition(teatable$DestTable):servingTea($CurDrink)"#]	</change1>
			request mover -m moveTo : moveTo($Dest)
		
		}
			
	}
	<tevid>Transition t0 whenReply done -> servTeaToClientPhase3</tevid>
	
	<sevid>State servTeaToClientPhase3</sevid> {
			onMsg(done : done(X,Y)){
				<change1>updateResource[#"atPosition(teatable$DestTable,${payloadArg(0)},${payloadArg(1)}):teaServed:$DestTable:$CurDrink"#]</change1>
				delay 1000
				//emit teaServed : teaServed($DestTable, $CurDrink )
				//start counting for consumingTime NOW
				//start timer to count until MaxStayTime
				println("Waiter resuming rimer for client...")
				forward mastertimer -m resumeTimer : resumeTimer($DestTable)
				
			}
	}		
	<change2>Goto checkForOtherPrioritizedTasks if [# WasCleaning == true #] else doATask</change2>
	
	<comm>/****************************************************************************************************/</comm>
	
	<comm>/**************************************  WAITER HANDLE PAYMENT **************************************/</comm>
	
	<change3>State handlePaymentPhase0</change3> {
		onMsg(billPlease : billPlease(T)){
			
			if [# WasCleaning == true #]{
				[# var TempTime = 0L #]
				memoCurrentTime TempTime
				[# TimeToClean = TimeToClean - (TempTime - TimeCleanBegan) #]
				println("waiter | interrupted cleaning to handle payment request")
			}
			
			[# var Teatable = payloadArg(0).toInt() #]
			
			//Was billPlease sent after a timeout for that client was triggered?
			if [# stopHandlingClientAtTable.get(Teatable)!! == true #] { 
					println("waiter | ignoring billPlease message for table $Teatable since it's client timed-out...")
					[# stopCheck = true #]
					//ignore message
			}
			else{
					// stopping timer
					println("waiter | Client at table $Teatable is ready to pay. Ending timer for table $Teatable")
					forward mastertimer -m endTimer : endTimer($payloadArg(0))
		
					
					[# stopHandlingClientAtTable.put(Teatable, true) #] //remember past end for simultaneous timeout/billPlease message handling 
					[# stopCheck = false #]
					
					//memorizing teatable_id for next phase
					[#
						DestTable = Teatable
					#]
			}
		}
	}
	<change3>Goto handlePaymentPhase1 if [# stopCheck == false #] else checkIfWasCleaning</change3>
	
	<sevid>State handlePaymentPhase1</sevid>{
		
		// reaching table
		println("waiter | Reaching table ${payloadArg(0)} ...")
		<change1>updateResource[#"reachingPosition(teatable$DestTable)"#]</change1>
		[# var Dest = "teatable" + DestTable #]
		request mover -m moveTo : moveTo($Dest)
	}
	<tevid>Transition t0 whenReply done -> handlePaymentPhase2</tevid>
	
	<sevid>State handlePaymentPhase2</sevid> {
		
		onMsg(done : done(X,Y)){
			println("waiter | Asking Client at table $DestTable to pay ...")
			<change1>updateResource[#"atPosition(teatable$DestTable,${payloadArg(0)},${payloadArg(1)}):clientPaying:$DestTable"#]</change1>
			delay 500
//			emit cardPlease : cardPlease($DestTable) 
			//get client_id from table_id
			request tearoom -m getRoomState : getRoomState(getClientFromTable, $DestTable)
		
		} 
	}
	<tevid>Transition t0 whenReply state -> convoyClientToExitPhase1</tevid>
	
	<sevid>State convoyClientToExitPhase1</sevid> {
		onMsg(state : state(C)){
			println("waiter | Convoying Client ${payloadArg(0)} to exit door ...")
			[# ClientToConvoy = payloadArg(0)#]
			<change1>updateResource[#"convoyingClientToExitDoor($ClientToConvoy)"#]</change1>
			request mover -m moveTo : moveTo(exit)
		}
	}
	<tevid>Transition t0 whenReply done -> convoyClientToExitPhase2</tevid>
	
	<sevid>State convoyClientToExitPhase2</sevid> {
		onMsg(done : done(X,Y)){
			println("waiter | saying goodbye to client $ClientToConvoy...")
			<change1>updateResource[#"atPosition(exit,${payloadArg(0)},${payloadArg(1)}):clientExiting:$ClientToConvoy"#]</change1>
//			emit exitPlease : exitPlease($ClientToConvoy)
			delay 500
			//updating teatable state
			forward tearoom -m updateState : updateState(updateTableState, $DestTable, dirty, ARG)
			//remember to clean the table
			forward waiter -m cleanTable : cleanTable($DestTable)
		}
	}
	<change2>Goto checkForOtherPrioritizedTasks if [# WasCleaning == true #] else doATask</change2>
	
	<comm>/****************************************************************************************************/</comm>
	
	<comm>/**************************************  WAITER HANDLE SLOW CLIENT **************************************/</comm>
	
	
	<change3>State handleTimeoutPhase0</change3> {
		println("waiter | inside handleTimeoutPhase0")
		onMsg(timeout : timeout(T)){
			println("waiter | inside handleTimeoutPhase0 AND onMsg!")
			[# var Teatable = payloadArg(0).toInt() #]
			
			//if already receive a billPlease it's a case of simultaneously billPlease - timeout
			if [# stopHandlingClientAtTable.get(Teatable)!! == true #] { 
					println("waiter | ignoring timeout message for table $Teatable since it's client was already handled...")
					[# stopCheck = true #]
					//ignore message
			}
			else{
					println("waiter | Time exceeded for client at table $Teatable")
					println("waiter | reaching table $Teatable...")
					[# stopHandlingClientAtTable.put(Teatable, true) #] //remember past end for simultaneous timeout/billPlease/wantToOrder message handling 
					[# stopCheck = false #]
					
					[#
						DestTable = Teatable	
					#]
			}
		}
	}
	<change3>Goto handleTimeoutPhase1 if [#stopCheck == false#] else doATask</change3>
	
	<sevid>State handleTimeoutPhase1</sevid> {
		
		<change1>updateResource[#"reachingPosition(teatable$DestTable)"#]</change1>
		[# var Dest = "teatable" + DestTable #]
		request mover -m moveTo : moveTo($Dest)
		
	}
	<tevid>Transition t0 whenReply done -> handleTimeoutPhase2</tevid>
	
	<sevid>State handleTimeoutPhase2</sevid> {
		onMsg(done : done(X,Y)){
			<change1>updateResource[#"atPosition(teatable$DestTable,,${payloadArg(0)},${payloadArg(1)}):maxTimeExceeded:$DestTable"#]</change1>
			println("waiter | communicating to client at table ${payloadArg(0)} that he has to pay and leave...")
//			emit maxTimeExceeded : maxTimeExceeded($payloadArg(0), $Price)	
			delay 800			
			//get client_id from table_id
			request tearoom -m getRoomState : getRoomState(getClientFromTable, $DestTable)	
		}
			
	}
	<tevid>Transition t0 whenReply state -> convoyClientToExitPhase1</tevid>
	
}</code></pre>
			</li>
		</ul>
	</div>	
</div>

<h2>Test Plans</h2>
<div class="remark">

	<h4>Client MOCK - WebGUI</h4>
	<div>
		<p>
			Two are the main changes performed on the client gui for the sake of testing:

			<ol>
				<li>The client GUI now shows tearoom, barman and waiter states as the manager did before. Hence, the web server for the client web app now observes the CoAP resources associated with waiter, barman and tearoom actors. At every change of state, the web server will update the web-view with the new state thorugh web-sockes, as explained in the previous Sprints (for the manager GUI);</li>
				<li>To update the view in term of interaction elements (i.e. showing order button to let the client be able to trigger the order request), the client web server doesn't listen any more to an MQTT broker for the events sent by the waiter, but it takes advantage of the observed states (from the previous addition) and draws useful information from those (i.e. waiter state is "atPosition(teatable1,1,1:clientSitting:c4w65e4f5r4er7:1", then the client holding c4w65e4f5r4er7 id can sit at teatable 1 and the view should show the menu view).</li>
			</ol>
		</p>
		<p>Hereunder is reported the @Controller class. The parts taking care of the aforementioned aspecs will be highlighted: </p>
		<pre class="mytab"><code>@Controller
public class ProvaController {
	
	String appName     ="provaGui";
    String htmlPage  = "welcome";
    ConnQakCoapMine connQakSupportS;
    ConnQakCoapMine connQakSupportW;
    ConnQakCoapMine connQakSupportT;
    ConnQakCoapMine connQakSupportB;
   
    @Autowired
    ClientAttributes ca;
    
    @Autowired
    SimpMessagingTemplate smt;
    
    String[] tavoliClienti = {"",""};
    String stateT ="";
    String stateW ="";
    String stateB ="";
    ProvaController controller=this;
   
	public ProvaController() {
        connQakSupportS = new ConnQakCoapMine();
        connQakSupportW = new ConnQakCoapMine();
        connQakSupportT = new ConnQakCoapMine();
        connQakSupportB = new ConnQakCoapMine();
       
        connQakSupportS.createConnection("localhost", "8015", "ctxtearoom", "smartbell");
         <change_evid>stateB = connQakSupportB.createConnection("localhost", "8015", "ctxtearoom", "barman");</change_evid>
         <change_evid>stateW = connQakSupportW.createConnection("127.0.0.1", "8029", "ctxwaiter", "waiter");</change_evid>
         <change_evid>stateT = connQakSupportT.createConnection("localhost", "8015", "ctxtearoom", "tearoom");</change_evid>
  
	}
	
	
	/*--------------------------------------------MAPPING-----------------------------------------------------------*/
	
	@GetMapping("/")
	public String welcomePage(Model model, HttpSession s){
		
		System.out.println("________________________Welcome page requested: " + s.getId());
		
		 <change_evid>preparePageUpdating();</change_evid>
		try {
			Thread.sleep(350);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		 <change_evid>model.addAttribute("ts", stateT);</change_evid>
		 <change_evid>model.addAttribute("ws", stateW);</change_evid>
		 <change_evid>model.addAttribute("bs", stateB);</change_evid>
		return "welcome";
		
	}
	
	@PostMapping("/enter")
	public String afterRingPage(Model model, HttpServletResponse r) {
		System.out.println("________________________Client rang the smartbell... "+model);
		
		try {
			ApplMessage msg = MsgUtil.buildRequest("clientWebPage", "ring", "ring()", "smartbell");
			String answer = connQakSupportS.request( msg );
			
			while(!(model!=null)) {
				System.out.println("________________________Waiting for smartbell reply...");
				Thread.sleep(200);
			}
			
			System.out.println("_______________________Smartbell reply: "+answer);
			String html = this.getAccessResult(answer, model);
			r.addCookie(new Cookie("id",ca.getId()));
			r.addCookie(new Cookie("table","0"));

			try {
				Thread.sleep(350);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			 <change_evid>model.addAttribute("ts", stateT);</change_evid>
			 <change_evid>model.addAttribute("ws", stateW);</change_evid>
			 <change_evid>model.addAttribute("bs", stateB);</change_evid>
			return ""+html;	
		}
		catch(Exception e) {
			System.out.println("_________________________ERROR=" + e.getMessage());
			e.printStackTrace();
			
			try {
				Thread.sleep(350);
			} catch (InterruptedException er) {
				// TODO Auto-generated catch block
				er.printStackTrace();
			}
			 <change_evid>model.addAttribute("ts", stateT);</change_evid>
			 <change_evid>model.addAttribute("ws", stateW);</change_evid>
			 <change_evid>model.addAttribute("bs", stateB);</change_evid>
			return "welcome";
		}
	}
	
	@PostMapping("/order")
	public String wantToOrder(Model model, HttpServletResponse r){
		
		int tid = indexOf(ca.getId()) + 1;		
		ca.setTable(tid);
		System.out.println("_______________________Client wants to order...");
		connQakSupportW.forward(MsgUtil.buildDispatch(ca.getId(), "wantToOrder", "wantToOrder("+ca.getTable()+")", "waiter"));
		r.addCookie(new Cookie("id",ca.getId()));
		r.addCookie(new Cookie("table",""+ca.getTable()));

		try {
			Thread.sleep(350);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		 <change_evid>model.addAttribute("ts", stateT);</change_evid>
		 <change_evid>model.addAttribute("ws", stateW);</change_evid>
		 <change_evid>model.addAttribute("bs", stateB);</change_evid>
		return "order";
	}
	
	@PostMapping("/consume")
	public String afterOrder(@RequestParam String type, Model model, HttpServletResponse r){
		
		System.out.println("_______________________Client has requested " + type + " tea...");		
		connQakSupportW.forward(MsgUtil.buildDispatch("clientWebPage", "tea", "tea("+ca.getTable()+","+type+")", "waiter"));
		r.addCookie(new Cookie("id",ca.getId()));
		r.addCookie(new Cookie("table",""+ca.getTable()));
		model.addAttribute("teaOrdered", type);

		try {
			Thread.sleep(350);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		 <change_evid>model.addAttribute("ts", stateT);</change_evid>
		 <change_evid>model.addAttribute("ws", stateW);</change_evid>
		 <change_evid>model.addAttribute("bs", stateB);</change_evid>
		return "consume";
	}
	

	@PostMapping("/exit")
	public String afterOrder(Model model, HttpServletResponse r){
		
		System.out.println("_______________________Client has requested  the bill...");		
		connQakSupportW.forward(MsgUtil.buildDispatch(ca.getId(), "billPlease", "billPlease("+ca.getTable()+")", "waiter"));
		r.addCookie(new Cookie("id",ca.getId()));
		r.addCookie(new Cookie("table",""+ca.getTable()));

		try {
			Thread.sleep(350);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		 <change_evid>model.addAttribute("ts", stateT);</change_evid>
		 <change_evid>model.addAttribute("ws", stateW);</change_evid>
		 <change_evid>model.addAttribute("bs", stateB); </change_evid>
		return "exit";
	}
	
	
	/*-------------------------------------------UTILITIES------------------------------------------------------------*/
	
	public void updateWaiterResp(String testo, String topic) {
		smt.convertAndSend(topic, testo);
		System.out.println("____________________________Updating client web-view...");
		System.out.println("TOPIC: "+topic+"\nTESTO: "+testo);
	}	
	
	public String getAccessResult(String msg, Model m) {
		
		String msgArg = KotParser.getMessageArg(msg, "sendClientID");
		System.out.println(msgArg);
		String ret = "welcome";
		
		if(msgArg.equals("NO")) {
			System.out.println("________________________The client cannot enter... "+m);
			ret = "noAccess";
		}
		else {
			System.out.println("________________________The client can enter... "+m);
			m.addAttribute("waiterResp", "Waiting for waiter instructions...");
			ca.setId(msgArg);
			ret = "enter";
		}
		
		return ret;
		
	}


	public String[] getTavoliClienti() {
		return tavoliClienti;
	}

	private int indexOf(String id) {
		if(tavoliClienti[0].equals(id)) {
			return 0;
		}
		else {
			if(tavoliClienti[1].equals(id)) {
				return 1;
			}
			else
				return -1;
		}
	}
	
	 <change_evid>private void preparePageUpdating() {
	    	connQakSupportT.getClient().observe(new CoapHandler() {
				@Override
				public void onLoad(CoapResponse response) {
					stateT = response.getResponseText();
					System.out.println("MonitorController --> CoapClient changed ->" + stateT);
					System.out.println("_____________________Updating manager web view...");
					System.out.println("TOPIC: "+WebSocketConfig.topicForManager1+"\nTESTO: "+stateT);
					smt.convertAndSend(WebSocketConfig.topicForManager1, 
							new ResourceRepMine("" + HtmlUtils.htmlEscape(stateT)));
				}

				@Override
				public void onError() {
					System.out.println("MonitorController --> CoapClient error!");
				}
			});
	    	connQakSupportW.getClient().observe(new CoapHandler() {
				@Override
				public void onLoad(CoapResponse response) {
					stateW = response.getResponseText();
					System.out.println("MonitorController --> CoapClient changed ->" + stateW);
					System.out.println("_____________________Updating manager web view...");
					System.out.println("TOPIC: "+WebSocketConfig.topicForManager3+"\nTESTO: "+stateW);
					smt.convertAndSend(WebSocketConfig.topicForManager3, 
							new ResourceRepMine("" + HtmlUtils.htmlEscape(stateW)  ));
					
					WaiterUpdateResourceHandler.parseUpdate(controller, stateW);		
					
				}

				@Override
				public void onError() {
					System.out.println("MonitorController --> CoapClient error!");
				}
			});
	    	connQakSupportB.getClient().observe(new CoapHandler() {
				@Override
				public void onLoad(CoapResponse response) {
					stateB = response.getResponseText();
					System.out.println("MonitorController --> CoapClient changed ->" + stateB);
					System.out.println("_____________________Updating manager web view...");
					System.out.println("TOPIC: "+WebSocketConfig.topicForManager2+"\nTESTO: "+stateB);
					smt.convertAndSend(WebSocketConfig.topicForManager2, 
							new ResourceRepMine("" + HtmlUtils.htmlEscape(stateB)  ));
				}

				@Override
				public void onError() {
					System.out.println("MonitorController --> CoapClient error!");
				}
			});
		}
}</change_evid></code></pre>
	<p>The updating is now done by another handler capable of parsing the updateResource String. It can be found at <a href="./WaiterUpdateResourceHandler.java">WaiterUpdateResourceHandler.java</a>. Hereunder is reported a piece of its code as an example:
	<pre class="mytab"><code>public final class WaiterUpdateResourceHandler {
	
	public static void parseUpdate(ProvaController pc, String update) {
		
		if(update.contains("clientSitting")) {
			parseSit(pc,update);
		}
		else if(update.contains("clientOrdering")) {
			parseOrder(pc,update);
		}
		else if(update.contains("teaServed")) {
			parseServed(pc,update);
		}
		...
	}

	private static void parseEnter(ProvaController pc, String update) {
		String[] elem = getElements(update,":");
		System.out.println("__________Client "+elem[2]+" can enter now");
		String resp="Waiter :- Please, follow me...";
		pc.updateWaiterResp(resp, "/topic/"+elem[2]);
		
	}

	private static void parseWait(ProvaController pc, String update) {
		String[] elem = getElements(update,":");
		long temp = Long.parseLong(elem[3]);
		long minutes = temp / (1000L*60L);
		long seconds = ( temp / 1000L ) % 60L;
		System.out.println("__________Client "+elem[2]+" has to wait");
		String resp="You have to wait at maximum " + minutes +" minutes and "+seconds+" seconds. Please, come again later. We are sorry for the waiting...";
		pc.updateWaiterResp(resp, "/topic/"+elem[2]);
	}
	
	...
}</code></pre>
	<p>Again, the client-side updating is taken care by <a href="./reception.js">reception.js</a> that now listens on other three different topics, one for actor (/topic/displybarman , /topic/displytearoom , /topic/displaywaiterstate ).</p>
	<p>All the other files can be found here:
		<ul>
			<li><a href="./WebSocketConfig.java">WebSocketConfig.java</a></li>
			<li><a href="./ProvaController.java">ProvaController.java</a></li>
		</ul>
	</p>
	</div>
	<h4>Testing with client in action</h4>
	
	<center><video width="80%" controls>
		<source src="./video/threeclients.mp4" type="video/mp4">
		<source src="./video/threeclients.ogg" type="video/ogg">
		Your browser does not support the video tag.
	</video></center>
	
	<!--<h4>Automated Test Plans</h4>-->
</div>

</div>



 <!--------------------------------------------------------------------------------------------------------------------------------->

<table id="authors" border="1" align="center">
<tr>
<td style="width:50%">
<center>By Elena Martini ~ email: elena.martini6@studio.unibo.it</center> 
</td>
<td style="width:50%">
<center>By Elisa Drudi ~ email: elisa.drudi4@studio.unibo.it </center>
</td>
</tr>
<!-- ---------------->
<tr>
<td style="width:50%">
<center><img src="./img/elena.jpg" alt="mbot" width="100%"></center>
</td>
<td style="width:50%">
<center><img src="./img/elisa.jpg" alt="mbot" width="100%"></center>
</td>
</tr>
</table>  
</body>
</html>

<html><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><meta name="Robots" content="NOINDEX " /></head><body></body>
                <script type="text/javascript">
                 var gearPage = document.getElementById('GearPage');
                 if(null != gearPage)
                 {
                     gearPage.parentNode.removeChild(gearPage);
                     document.title = "Error";
                 }
                 </script>
</html>