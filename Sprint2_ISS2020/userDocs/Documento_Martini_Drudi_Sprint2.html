<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
<!--
body
{
    margin-left:  30px;	
    margin-right: 30px;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #1F37B5;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}
h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
	border-radius: 10px;
	padding: 5px;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #9ed8ff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #C0F0E0;
    font-size: 100%;
	width: 100%;
	border-radius: 5px;
	padding: 5px;
}
h5 {
    background-color: #d5ffb0;
    font-size: 100%;
	border-radius: 5px;
	padding: 3px;
	
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #154A7E;
	padding: 1px;
	border-radius: 5px;
}
ks{
	background-color: #E8FFD3;
	padding: 1px;
	padding-left: 3px;
	padding-right: 3px;
	border-radius: 5px;
	 
}
pre{
	font-family: "Consolas";
	font-size: 80%;
	background-color: #F8FFFD;
	border: 1.5px solid #90E4C8;
	padding: 10px;
	border-radius: 10px;
	word-break: keep-all;
	white-space: pre-wrap;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
    font-size: 19px;
	line-height: 110%;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}       
div.remark{
	background-color: #ffffff;	
    border: 1.5px solid #d5f2ed;
    padding: 15px;
	padding-left: 20px;
	padding-right: 30px;
    margin: 10px;
	border-radius: 25px;
}  
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

ul{
	margin: 10px;
	margin-left: 20px;
	padding: 0;
}

li{
	padding-top: 5px;
}

table, th, td {
	border: 2px solid #d5f2ed;
}
td{
	padding: 10px;
}

#authors {
	width: 600px;
	border: 2px solid #AB55FF;
}

#authors td {
    background-color: #b2c0ff;
	padding: 10px;
	border: 2px solid #AB55FF;
}
i{
	font-weight: bold;
}
tl, ttr{
	color: #154A7E;
	font-weight: bold;
}
ttr{
	font-style: italic;
}
.mytab{
	tab-size: 4;
}
keyw{
	color: #B12283;
	font-weight: bold;
}
comm{
	color: #00BD06;
}
strs{
	color: #145CDE;
}
ints{
	color: #E7BE41;
	}
p.did{
	margin: 0;
	padding-bottom: 10px;
	padding-top: 0;
	padding-left: 15px;
	padding-right: 5px;
	font-size: 18px;
	border-left: 1.5px dashed silver;
}
sevid{
	background-color: #A8ECC7;
	border-radius: 5px;
	padding: 2px;
}
tevid{
	border-radius: 5px;
	padding: 2px;
	border: 2px solid #A8ECC7;
	line-height: 24px;
}
mevid{
	background-color: #D4F7E4;
}
change_evid{
	background-color: #FFFF99;
	border-radius: 5px;
	padding: 2px;
}
schange_evid{
	background-color: #FFE699;
	border-radius: 5px;
	padding: 2px;
}
tchange_evid{
	border-radius: 5px;
	padding: 2px;
	border: 2px solid #FFE699;
	line-height: 24px;
}
  -->
</style>
    
<head>
   
<title>Tearoom - sprint 2</title></head>
    
<body>
<div id="top">
<h1>Safe Tearoom COVID-19 - Sprint 2<font size="5"></font> </h1>
</div>  

<div class="body"> 

<!--<h2>Introduction</h2>
<div class="remark">
</div>-->

<h2>Requirements</h2>
<div class="remark">
	
	<h4>Requirements</h4>
	<div>
		A complete list of requirement can be found here: <a href="https://htmlpreview.github.io/?https://github.com/anatali/iss2020LabBo/blob/master/it.unibo.issLabStart/userDocs/TemaFinaleBo20.html">Tearoom COVID-19</a>.
	</div>
	
	<h4><a name="assumption"></a>Assumptions for Sprint 2</h4>
	<div>
		</br>In this second sprint the following assumptions will be considered :</br>
		<ul>
			<li><i>assumption 1</i> : there will be two customer at the same time in the tearoom (instead of one) and we also assume that any client will arrive only if there is at least one free and clean teatable</li>
			<li><i>assumption 2</i> : task will be handled in order of arrival (no priority policy) with the exception of cleaning the table. The action of cleaning a table may be interupted to execute tasks that have higher priority (actions that let the custumers wait less time for the service)</li>
			<li><i>assumption 3</i> : we will develop a Manager's web page to monitor states interesting for this second Sprint (no Hall state for now)</li>
		</ul>
		</br>
		With our first Sprint we manage to develop a complete (from start to finish) Waiter's workflow for one client. We will now <em>focus on improving our system to be able to handle two client at the same time</em> inside the safe tearoom. Furthermore, we can use the web app developed to simulate a client in the previous Sprint as a starting point for the development of the Manager's web app. </br></br>
		By progressively relaxing assumption and improving our system we can incrementally integrate all the requirements. Working with subset of problems at a time (instead of all the problems at the same time) helps our team to reduce the complexity of developing the system. 
	</div>
</div>

<h2>Requirement analysis</h2>
<div class="remark">
	<ol>
		<li><h4>Introduction</h4>
		
			<div>		
				Since most of the requirement analysis done during Sprint 1 remains valid for this second Sprint we will report hereunder only the aspects that have changed due to the new assumptions. The requirement analysis written for the previous Sprint can be found here : <a href="https://htmlpreview.github.io/?https://github.com/gitemar/Martini_Drudi_ISS2020/blob/master/Sprint1_ISS2020/userDocs/Documento_Martini_Drudi_Sprint1.html">Tearoom COVID-19 - Sprint 1</a>.
			</div>
			
			<h5>Manager</h5>
			Although the requirements for the manager have not changed it is worth noting that the <i>Hall state</i> is not interesting to observe since we decided with <u>assumption 1</u> that we will have exactly two client inside the tearoom (meaning no client will ever have to wait outside). Therefor hall state will not be considered by the Manager's web page for this second Sprint.
			
			</br></br>
			Summarizing the states that the Manager can observe using the web gui that we will provide will be:
			<ul>
				<li><i>Teatables states</i>: it stores information about the presence of a customer at a table and if the table is clean or not;</li>
				<li><i>Waiter state</i>: it stores information about the task that the waiter is currently performing;</li>
				<li><i>Barman state</i>: it stores information about the task that the barman is currently performing;</li>
			</ul>
			

			<h5>Waiter</h5>
			One of the requirement given by our client is to reduce as much as possible the waiting time of the requests coming from each client. This means that our waiter should prioritize action related to active client inside the tearoom than action not related to them. This requirement could be ignored in Sprint 1 since the presence of only one client meant that the waiter was dedicated to that client and the waiting time was already at the minimum. Now that we have two client at the same time we need to re-evaluate its significance and the impact this has on our system. </br></br>
			
			After a second discussion with the client it was decided by mutual agreement that the action of cleaning a table must be done only if no action related to active client inside the room can be performed. 
			</br>
			As analysts we have also considered other actions that can be performed by the waiter to see if some of these should be considered with a different degree of priority. We came to the conclusion that only the action of cleaning a teatable is not directly linked to the active customers inside the safe tearoom and therefore it's the only one that needs to have a lower priority.
			
			
			</ul>
		</li>
		
		<li><h4>Model of the requirements</h4>

		As already described in the document of the Sprint 1 we will use QAkctor modelling language to formalize the essential aspects of our system.
		
		In this section we will report only the differences with respect to what was written in the previous document.
		
		<h5>Qak Smartbell model</h5>
		<center><img src="img/req_smartbellactor.png" alt="req_smartbellactor.png" width="50%"/></center>
	
		<div> This model remained unchanged from the previous Sprint </div>

		<h5>Qak Barman model</h5>
		<center><img src="img/req_barmanactor.png" alt="req_barmanactor.png" width="50%"/></center>
		<div> This model remained unchanged from the previous Sprint </div>
		
		
		<h5>Qak Waiter model</h5>
		<center><img src="img/req_waiteractor.PNG" alt="req_waiteractor2.PNG" width="50%"/></center>
		</br>
		In the waiter model we reported the client-waiter interaction messages: as already examined in the previous Sprint document, the Client is not part of our system (that the team has to develop), but only a component to mimic/simulate a real-person client/customer. Therefore, all client-waiter interaction relative messages are there only as a tool to test the waiter and, then, as a way to better understand the essential aspects of the waiter actor.
		</br></br>
		Following some observations on the previous client and waiter models, the team decided to substitute client-waiter request-reply interactions with dispatch and event messages (this decision brought a change on wantToOrder-orderPlease and billPlease-cardPlease messages): a dispatch-event better catch the idea of a real client that won't wait in a blocking way for the waiter to arrive at the table, but will go on doing something else (like texting with a friend, calling someone on the phone...). Hence, we decided to apply a less blocking and more asynchronous interaction between the two actors.
		</br>
		@TONNO : controllare consistenza timeout message
		<pre class="mytab"><code><keyw>System</keyw> waiter

<comm>//-----------SMARTBELL COMMMUNICATION--------------</comm>
<keyw>Dispatch</keyw> enter : enter(CLIENT_ID)	         
<comm>//-------------------------------------------------</comm>

<comm>//----------CLIENT COMMUNICATION--------------------------------</comm>
<keyw>Event</keyw> wait            : wait(CLIENT_ID, MAX_TIME)		  
<keyw>Event</keyw> sitPlease       : sitPlease(CLIENT_ID, TEATABLE_ID)
<keyw>Dispatch</keyw> wantToOrder  : wantToOrder(TEATABLE_ID)
<keyw>Dispatch</keyw> tea          : tea(TEATABLE_ID, TEA)		  
<keyw>Event</keyw> teaServed       : teaServed(TEATABLE_ID, TEA)	  
<keyw>Event</keyw> orderPlease     : orderPlease(TEATABLE_ID)		  
<keyw>Dispatch</keyw> billPlease   : billPlease(TABLE_ID)			 
<keyw>Event</keyw> cardPlease      : cardPlease(ARG)				  
<keyw>Event</keyw> maxTimeExceeded : maxTimeExceeded(TEATABLE_ID)	  
<keyw>Event</keyw> exitPlease      : exitPlease(CLIENT_ID)			  
<comm>//--------------------------------------------------------------</comm>

<comm>//-----------BARMAN COMMUNICATION-----------------------------</comm>
<keyw>Dispatch</keyw> order : order(TEATABLE_ID,TEA)						
<keyw>Dispatch</keyw> ready : ready(TEATABLE_ID,TEA)						
<comm>//------------------------------------------------------------</comm>

<comm>//----------SELF MESSAGES-------------------------------------</comm>
<keyw>Dispatch</keyw> cleanTable : cleanTable (TEATABLE_ID)				
<comm>//------------------------------------------------------------</comm>

<comm>//-----------TIMER COMMMUNICATION-----------------------------</comm>
<keyw>Dispatch</keyw> startTimer  : startTimer(TEATABLE_ID, MAX_TIME)		
<keyw>Dispatch</keyw> stopTimer   : stopTimer(TEATABLE_ID)					
<keyw>Dispatch</keyw> resumeTimer : resumeTimer(TEATABLE_ID)				
<keyw>Dispatch</keyw> endTimer    : endTimer(TEATABLE_ID)					
<keyw>Event</keyw> timeout     : timeout(TEATABLE_ID)						
<comm>//------------------------------------------------------------</comm></code></pre>
		<p>In the space below we have reported the new qak model which has undergone some changes compared to the previous version.</p>
		<p>The action of cleaning a teatable has therefore been modified in such a way that the arrival of any other message (and so a new task to perform) interrupts it. By doing this, the waiter can give priority to other actions which, as already explained, contribute to the goal of <u>making customers wait as little as possible inside the tearoom</u>.
		</br>Changes related to the interruptible cleaning action are highlited in <change_evid>yellow</change_evid> and <schange_evid>orange</schange_evid> since they make up the majority of the changes made to the waiter.</p>
		<pre class="mytab"><code>Context ctxsmartbell 	ip [host="localhost" port=8030]
Context ctxclient 	ip [host="whateverip" port=8077]
Context ctxbarman 	ip [host="localhost" port=8066]
Context ctxwaiter 	ip [host="127.0.0.1" port=8020]
Context ctxtimer 	ip [host="someip" port=8010]

ExternalQActor barman 	 context ctxbarman
ExternalQActor smartbell context ctxsmartbell
ExternalQActor client 	 context ctxclient
ExternalQActor timer 	 context ctxtimer


<sevid>QActor waiter</sevid> context ctxwaiter {
	[# 
		var MaxWaitTime : Long
		val MaxStayTime = 10000L   	// 10 sec
		val IdleTime = 200L			// 200 ms
		var ClientToConvoy = ""
		
		//variables useful for handling the action of cleaning table
		<change_evid>val CleanTime = 2000L</change_evid>
		<change_evid>var RemainigCleaningTime = CleanTime</change_evid>
		<change_evid>var teatableToClean = 0</change_evid>
	#]
	
	<sevid>State s0 initial</sevid>{
		discardMsg Off <comm>//we don't want to loose any message</comm>
	}
	<tevid>Goto restingAtHome</tevid>
	
	<sevid>State restingAtHome</sevid>{
		if [# currentPos() != HomePos() #] { [# goToHome() #]}
		println("waiter | No task to do. Chilling out at home...")	
	}
	<tevid>Transition t0   whenMsg enter -> handleEnter</tevid>
					<tevid>whenEvent timeout -> handleTimeout</tevid>
					<tevid>whenMsg wantToOrder -> handleOrder</tevid>
					<tevid>whenMsg ready -> serveTeaToClient </tevid>
					<tevid>whenMsg billPlease -> handlePayment </tevid>
					<tevid>whenMsg cleanTable -> cleanTeatable</tevid>
					
					
	<sevid>State doATask</sevid>{
		println("waiter | checking if there is a task to do...")
	}
	<tevid>Transition t0   whenTimeVar IdleTime -> restingAtHome</tevid>
					<tevid>whenMsg enter -> handleEnter</tevid>
					<tevid>whenEvent timeout -> handleTimeout</tevid>
					<tevid>whenMsg wantToOrder -> handleOrder</tevid>
					<tevid>whenMsg ready -> serveTeaToClient</tevid>
					<tevid>whenMsg billPlease -> handlePayment </tevid>
					<tevid>whenMsg cleanTable -> cleanTeatable</tevid>
					
					
	<sevid>State handleEnter</sevid>{
		onMsg(enter : enter(CLIENT_ID)){
		
		<change_evid>if [# wasCleaningActionInterrupted() #]{</change_evid>
				<change_evid>[# RemainigCleaningTime = calculateNewCleaningTimeForTeatable(teatableToClean)#]</change_evid>
		<change_evid>}</change_evid>
		
			println("waiter | a client with client_id ${payloadArg(0)} asked to enter the safe tearoom...")
			if [# freeAndCleanTable() == 0 #] { //NO free and clean table
				[# 
					MaxWaitTime =  getMaxWaitTime()
				#]
				println("waiter | ... but since there is no free and clean teatable I ask ${payloadArg(0)} to wait a little ($MaxWaitTime)!")
				<mevid>emit wait : wait($payloadArg(0), $MaxWaitTime)</mevid>
			}
			else {	// there is a free and clean table
				println("waiter | ... and since there is a free and clean teatable I let ${payloadArg(0)} in!")
				//convoying is atomic with enter when there is a free table
				[# ClientToConvoy = payloadArg(0) #]
			}
		} //onMsg
	}
	<comm>//In this second Sprint since we will handle exactly 2 customer it will never happen that a client has to wait
	// so freeAndCleanTable is always > 0</comm>
	<tchange_evid>Goto convoyClientToTable if [# freeAndCleanTable() > 0 #] else checkIfWasCleaning</tchange_evid>
	
	<schange_evid>State checkIfWasCleaning</schange_evid>{ 
		<comm>//Temporary state made to implement an else-if statement for Transition from state related to action that can
		// interrupt cleaning action</comm>
	}
	<tchange_evid>Goto cleanTeatable if [# wasCleaningActionInterrupted() #] else doATask</tchange_evid>
	
	
	<sevid>State convoyClientToTable</sevid>{
		[#
			var Teatable = getFreeAndCleanTeatable()	//ID teatable
			MaxWaitTime = 0L 
			goToEntranceDoor()		//prepare to convey the client to a teatable
		#]
		<mevid>emit wait : wait($ClientToConvoy , $MaxWaitTime)</mevid>
		println("waiter | convoying client $ClientToConvoy to teatable $Teatable ...")
		[#
			reachTeatablePos(Teatable)
			updateTeatableState(Teatable, "BUSY")
		#]
		<mevid>emit sitPlease : sitPlease($ClientToConvoy, $Teatable )</mevid>
		//start timer to count until MaxStayTime
		<mevid>forward timer -m startTimer : startTimer($Teatable)</mevid>
	}
	<tchange_evid>Goto cleanTeatable if [# wasCleaningActionInterrupted() #] else doATask</tchange_evid>
	
		
	<sevid>State cleanTeatable</sevid>{
		onMsg(cleanTable : cleanTable(T)) {
			<change_evid>//first we reach the teatable</change_evid>
			<change_evid>[#reachTeatablePos(payloadArg(0))#]</change_evid>
			<change_evid>// then we clean the teatable</change_evid>
			<change_evid>println("waiter | cleaning the teatable ${payloadArg(0)}")</change_evid>
			<change_evid>[#teatableToClean = payloadArg(0).toInt()#]</change_evid>
		} //onMsg
		
		<change_evid>if [#wasCleaningActionInterrupted()#] {</change_evid>
			<change_evid>//first we reach the teatable</change_evid>
			<change_evid>[#reachTeatablePos(teatableToClean)#]</change_evid>
			<change_evid>// then we clean the teatable</change_evid>
			<change_evid>println("waiter | retry to finish cleaning the teatable $teatableToClean")</change_evid>
		}
	}
	//cleaning is an interruptible action that MUST be interrupted if Waiter can perform other actions
	<tchange_evid>Transition t0 	whenTimeVar RemainigCleaningTime -> cleaningFinished</tchange_evid>
					<tchange_evid>whenMsg enter -> handleEnter</tchange_evid>
					<tchange_evid>whenMsg wantToOrder -> handleOrder</tchange_evid>
					<tchange_evid>whenMsg ready -> serveTeaToClient</tchange_evid>
					<tchange_evid>whenMsg billPlease -> handlePayment</tchange_evid> 
	
	
	<schange_evid>State cleaningFinished </schange_evid> {
			<change_evid>//update teatable state</change_evid>
			<change_evid>[#updateTeatableState(payloadArg(0), "CLEAN")#]</change_evid>
			<change_evid>//reset RemainigCleaningTime for that table</change_evid>
			<change_evid>[#RemainigCleaningTime = resetRemainingCleaningTime()#]</change_evid>
	}
	//As we have just one client at a time (Assumption 1), we don't have to check if there are clients waiting to enter
	<tchange_evid>Goto doATask</tchange_evid>
	
	
	<sevid>State handleOrder</sevid>{
		onMsg(wantToOrder : wantToOrder(TABLE)){
		
			<change_evid>if [# wasCleaningActionInterrupted() #]{</change_evid>
				<change_evid>[# RemainigCleaningTime = calculateNewCleaningTimeForTeatable(teatableToClean)#]</change_evid>
			<change_evid>}</change_evid>
		
			//Stop counting for orderTime now
			<mevid>forward timer -m stopTimer : stopTimer($payloadArg(0))</mevid>
			
			//reach teatable position to simulate the action of taking an order
			[#reachTeatablePos(payloadArg(0))#]
			//simulating the action of asking the client what he want to order
			<mevid>emit orderPlease : orderPlease($payloadArg(0))</mevid>
			
		}
	}
	Transition t0 whenMsg tea -> takingOrder
	
	<sevid>State takingOrder</sevid> {
		onMsg(tea : tea(T, TEA)){
			//send the order to barman
			println("waiter | client at teatable ${payloadArg(0)} ordered a ${payloadArg(1)}! Sending order to Barman...")
			<mevid>forward barman -m  order : order($payloadArg(0), $payloadArg(1))</mevid>
		}
	}
	<tchange_evid>Goto cleanTeatable if [# wasCleaningActionInterrupted() #] else doATask</tchange_evid>
	
	<sevid>State serveTeaToClient</sevid>{
		onMsg(ready : ready(T,D)){
		
			<change_evid>if [# wasCleaningActionInterrupted() #]{</change_evid>
				<change_evid>[# RemainigCleaningTime = calculateNewCleaningTimeForTeatable(teatableToClean)#]</change_evid>
			<change_evid>}</change_evid>
		
			println("waiter | order for table ${payloadArg(0)} ready! Serving order...")	
			[# goToServiceDesk() #]
			delay 200
			[#
				reachTeatablePos(payloadArg(0))	
			#]
			<mevid>emit teaServed : teaServed($payloadArg(0), $payloadArg(1) )</mevid>
			//start counting for consumingTime NOW
			//start timer to count until MaxStayTime
			<mevid>forward timer -m resumeTimer : startTimer($payloadArg(0))</mevid>
		}
	}
	<tchange_evid>Goto cleanTeatable if [# wasCleaningActionInterrupted() #] else doATask</tchange_evid>
	
	<sevid>State handlePayment</sevid>{
		onMsg(billPlease : billPlease(T)){
		
			<change_evid>if [# wasCleaningActionInterrupted() #]{</change_evid>
				<change_evid>[# RemainigCleaningTime = calculateNewCleaningTimeForTeatable(teatableToClean)#]</change_evid>
			<change_evid>}</change_evid>
		
			[#
				ClientToConvoy = getClientAtTable(payloadArg(0))
			#]
			println("waiter | ending timer for table ${payloadArg(0)}")
			<mevid>forward timer -m endTimer : endTimer($payloadArg(0))</mevid>
			
			println("waiter | client at table ${payloadArg(0)} finished before MaxStayTime expired...")
			println("waiter | Reaching table ${payloadArg(0)} ...")
			[#reachTeatablePos(payloadArg(0))#]
			println("waiter | Arrived at table ${payloadArg(0)}, requesting credit card...")
			<mevid>replyTo billPlease with cardPlease : cardPlease(amount_to_pay)</mevid>		
		}
		
		delay 200 //simulating client giving credit card and payment time
		println("waiter | convoying client to exit door...")
		[#goToExitDoor()#]
		<mevid>emit exitPlease : exitPlease($ClientToConvoy)</mevid>
		
		//waiter sends itself a message to remember to clean the table
		[# TableToClean = getTableFromClientID(ClientToConvoy)#]
		<mevid>forward waiter -m cleanTable : cleanTable($TableToClean)</mevid>
		
		//update teatable state
		[#updateTeatableState(TableToClean, "DIRTY")#]
	}
	<tchange_evid>Goto cleanTeatable if [# wasCleaningActionInterrupted() #] else doATask</tchange_evid>
	
	<sevid>State handleTimeout</sevid>{
		onMsg(timeout : timeout(T)){
			println("waiter | Time exceeded for client at table ${payloadArg(0)}")
			println("waiter | reaching table ${payloadArg(0)}...")
			[#
				reachTeatablePos(payloadArg(0))
				ClientToConvoy = getClientAtTable(payloadArg(0))
			#]
			println("waiter | communicating to client $ClientToConvoy that he has to pay and leave...")
			<mevid>emit maxTimeExceeded : maxTimeExceeded($payloadArg(0), amount_to_pay)</mevid>			
		}	
	}
	<tevid>Goto handlePayment</tevid>	
}</code></pre>
		<p>It is worth noting that as Analyst we decide to not interrupt the cleaning action if a timeout happen. We consider this situation as giving a little more time and letting the client
		 finish it's drink while the waiter finish it's current action. Furthermore, in this case, interrupting the cleaning action is not useful to reduce the waiting times of active customers in the safe tearoom but it is only a way to free a teatable faster, which in any case must be cleaned before it can be used.</p>
		</li>
		<li><h4>Functional TestPlan</h4>
		<p>The considerations made in the last sprint (<a href="https://htmlpreview.github.io/?https://github.com/gitemar/Martini_Drudi_Safe_Tearoom/blob/master/week_2_step_1/userDocs/Documento_Martini_Drudi.html">Sprint 1</a>) are still valid in this second Sprint.

</p>

		
		<h5>Client MOK</h5>
			
		<center><img src="img/req_clientactor.png" alt="req_clientactor.png" width="50%"/></center>
		<p>Here, since the <i>client</i> should be a human being, there is the need of MOK messages to simulate a correct human behaviour. Hereunder are described the messages related to the client actor (qakctor).</p>
		<pre class="mytab"><code><keyw>System</keyw> client

<keyw>Request</keyw> ring : ring(ARG)
<keyw>Reply</keyw> sendClientID : sendClientID(CLIENT_ID)
<keyw>Event</keyw> wait : wait(CLIENT_ID, MAX_TIME)
<keyw>Event</keyw> sitPlease : sitPlease(CLIENT_ID, TEATABLE_ID)
<keyw>Dispatch</keyw> tea : tea(TEA)
<keyw>Event</keyw> teaServed : teaServed(TEATABLE_ID, TEA)
<keyw>Dispatch</keyw> billPlease : billPlease(TEATABLE_ID)
<keyw>Event</keyw> cardPlease : cardPlease(TEATABLE_ID)
<keyw>Event</keyw> maxTimeExceeded : maxTimeExceeded(TEATABLE_ID) //the waiter sends this message when it is already at the table
<keyw>Event</keyw> exitPlease : exitPlease(CLIENT_ID)</code></pre>
		<p class="did">All interactions have been modeled as "fire-and-forget" (message events and dispatching) since a request-reply interactions doesn't seem to be needed from requirements (sender doen't need a specific reply from receiver). Moreover, the waiter doesn't know directly the client (apart from its client identifier), hence it needs to communicate through events.</p>
	
		<p>
			The client MOK has changed only in the request-reply messages as described in the waiter QAK model. This way (with a dispatch-event interaction), when a client wants to order or wants to pay, the web page won't block, but a "waiting message" will be displayed, so that the client knows that the waiter will arrive at its table as soon as possible. 
		</p>
		</li>
	</ol>
</div>

<!--



		
		PROBLEM ANALYSIS START




-->

<h2>Problem analysis</h2>
<div class="remark">
	<ol>
		<li><h4><a name="logicarch"></a>Logical architecture:</h4>
			<p>The logical system architecture remained mostly unchanged and it's described by the underlying image:</p>
			<center><img src="./img/prob_allactors.png" alt="all actors" width="100%"></center>
			<p>
				Due to the possibility of having two clients inside the tearoom at the same time, it is neccessary to take into account different timings, one for teatable. 
				</br></br>
				There are various ways of implementing the management of those timings: as analysts we found in a <em>mastertimer</em> actor a possible solution that allows us to hide timer realization details to the waiter (Information Hiding Principle).In fatc, the timer (mastertimer) exposes an interface that won't change and, at the same time, it allows the presence of highly specialized components (Single Responsibility Principle) that in the below model we called <i>subtimers</i>.
				</br>More details are provided in the mastertimer qak model.
				</br></br>
				However, it will be designers' duty (in a design phase) to decide which is the best choice for the timer implementation.
			</p>
			<center><img src="./img/prob_manager.png" alt="all actors" width="80%"></center>
			<p>The manager, through the web page, must be able to see the state of the main system components (Barman, Waiter and Tearoom). Therefore, it is necessary that these components expose their states to the outside and that the manager's web page is notified every time these states changes so as to be able to keep updated the information provided to the manager. As analysts we have concluded that in order to allow a real-time update, it is necessary for the components to notify the manager of the change in their states and not vice versa, i.e. the manager who periodically re-asks for their states. </br>Again, there are different ways to achieve this type of interaction and different technologies can be used. As analysts, we think CoAP may be a suitable choice. In fact, the team has already decided to use CoAP to make the states of the main actors accessible to the outside as a CoAP Resource so that we can use this information to design automated tests in the future.
			</p>
			<p>The Californium CoAP support framework used by the QAK infrastructure provides native support for CoAP's observe mechanism, so there is no need for the team to develop it from scratch. In particular, each CoAP Client can send a request for observation to a CoAP Resource. When this request is accepted, an ObserveRelation is established between Client and Resource and from that moment on any change in the state of the CoAP Resource can be notified by the CoAP Resource by invoking the changed() method. </br>Because of how the infrasctructure QAK is implemented, the invocation of the updateResource method within the QAK code automatically causes the invocation of the changed() method. Therefore, if the designers decide to continue on this path it would not be necessary to make any changes to the Barman, Waiter and Tearoom components but the only requirement is to create a Manager-side CoAP Client to handle these notifications.
			</p>
			<h5>Waiter QAKctor</h5>
			<pre class="mytab"><code><keyw>System </keyw> waiter

<keyw>mqttBroker</keyw> <strs>"localhost"</strs> : <ints>1883</ints> <keyw>eventTopic</keyw> "unibo/polar" 	<comm>//mqtt.eclipse.org</comm>

<comm>// Interaction Waiter - Mover =================================//</comm>
<keyw>Request</keyw> moveTo 	: moveTo(KEY_POSITION)						   
<keyw>Reply</keyw> done 		: done(X,Y)									   
<keyw>Dispatch</keyw> end 	: end(ARG)									  <comm> //	</comm>
<comm>//=============================================================//</comm>

<comm>// Interaction Waiter - Timer =================================//</comm>
<keyw>Dispatch</keyw> startTimer 	: startTimer(TEATABLE_ID, MAX_TIME)	   
<keyw>Dispatch</keyw> stopTimer 		: stopTimer(TEATABLE_ID)			   
<keyw>Dispatch</keyw> resumeTimer 	: resumeTimer(TEATABLE_ID)			   
<keyw>Dispatch</keyw> endTimer 		: endTimer(TEATABLE_ID)				   
<keyw>Event</keyw> timeout 			: timeout(TEATABLE_ID)				   
<comm>//=============================================================//</comm>

<comm>// Interaction Waiter - Tearoom ========================================//</comm>
<keyw>Request</keyw> getRoomState : getRoomState(REQUEST, ARG1)						
<keyw>Reply</keyw> state			 : state(STATE)										
<keyw>Dispatch</keyw> updateState : updateState (UPDATE_REQUEST, ARG1, ARG2, ARG3)	
<comm>//======================================================================//</comm>

<comm>// Interaction Waiter - Smartbell ============================//</comm>
<keyw>Dispatch</keyw> enter : enter(CLIENT_ID)						      
<comm>//============================================================//</comm>

<comm>// Interaction Waiter - Client ===============================//</comm>
<keyw>Event</keyw> wait 				: wait(CLIENT_ID, MAX_TIME)			 <comm> //</comm>
<keyw>Event</keyw> sitPlease 		: sitPlease(CLIENT_ID, TEATABLE_ID)   
<keyw>Dispatch</keyw> wantToOrder	: wantToOrder(TEATABLE_ID)	          
<keyw>Event</keyw> orderPlease		: orderPlease(ARG)					  
<keyw>Dispatch</keyw> tea 			: tea(TEATABLE_ID, TEA)				  
<keyw>Event</keyw> teaServed 		: teaServed(TEATABLE_ID, TEA)		  
<keyw>Dispatch</keyw> billPlease 	: billPlease(TABLE_ID)				  
<keyw>Event</keyw> cardPlease 		: cardPlease(ARG)					  
<keyw>Event</keyw> maxTimeExceeded 	: maxTimeExceeded(TEATABLE_ID)		  
<keyw>Event</keyw> exitPlease 		: exitPlease(CLIENT_ID)				  
<comm>//============================================================//</comm>

<comm>// Interaction Waiter - Barman  ==============================//</comm>
<keyw>Dispatch</keyw> order : order(TEATABLE_ID, TEA)					  
<keyw>Dispatch</keyw> ready : ready(TEATABLE_ID,TEA)						  
<comm>//============================================================//</comm>

<comm>// Interaction Waiter auto-message ===========================//</comm>
<keyw>Dispatch</keyw> cleanTable : cleanTable (TEATABLE_ID)				  
<comm>//============================================================//</comm></code></pre>
		</br>
		<p>Waiter has undergone some changes so that it would be able to manage the cleaning interruption as decribed in the Requirements Analysis:</p>
		<pre class="mytab"><code>Context ctxwaiter 		 	ip [host="127.0.0.1" port=8029]
Context ctxtearoom 		 	ip [host="localhost" port=8015]

ExternalQActor tearoom 		context ctxtearoom
ExternalQActor barman		context ctxtearoom
ExternalQActor smartbell	context ctxtearoom

CodedQActor datacleaner    	context ctxwaiter className "rx.dataCleaner"
CodedQActor distancefilter 	context ctxwaiter className "rx.distanceFilter"
CodedQActor basicrobot 		context ctxwaiter className "it.unibo.basicrobot.Basicrobot"
CodedQActor trustingwalker 	context ctxwaiter className "it.unibo.trustingwalker.Trustingwalker"
CodedQActor mastertimer		context ctxwaiter className "it.unibo.mastertimer.Mastertimer"

<sevid>QActor waiter</sevid> context ctxwaiter {
	
	[# 
		var MaxWaitTime = 0L
		val MaxStayTime = 10000L   	// 10 sec
		val IdleTime = 200L			// 200 ms
		
		var ClientToConvoy = ""
		var DestTable = -1
		var CurDrink = ""
		var Price = 3
		
		var TimeToClean = 2000L
		var TimeCleanBegan = 0L
		var WasCleaning = false
		var TableToClean = 0
	#]
	
	
	<sevid>State s0 initial</sevid> {
		
		//init
		println("waiter | beep beep boop...START...")
		
	}
	<tevid>Goto restingAtHome</tevid>
	
	<comm>// WAITER WAIT FOR TASK TO DO 1</comm>
	<sevid>State restingAtHome</sevid> {
		<change_evid>updateResource[#"atPosition(0,0,home)"#]</change_evid>
		println("waiter | Chilling out at home...")	
		
	}
	<tevid>Transition t0 	whenMsg enter -> handleEnterPhase1</tevid>
					<tevid>whenRequest wantToOrder -> handleOrderFromClientPhase1</tevid>
					<tevid>whenMsg ready -> serveTeaToClientPhase1</tevid>
					<tevid>whenEvent timeout -> handleTimeoutPhase1</tevid>
					<tevid>whenRequest billPlease -> handlePaymentPhase1 </tevid>
					<tevid>whenMsg cleanTable -> cleanTeatablePhase1</tevid>
	
	<comm>// WAITER WAIT FOR TASK TO DO 2</comm>
	<sevid>State doATask</sevid> {
		
		println("waiter | checking if there is a task to do...")
		
	}
	<comm>// if waiter has no task it go home to rest a little bit</comm>
	<tevid>Transition t0 	whenTimeVar IdleTime -> goHome	</tevid>			
					<tevid>whenMsg enter -> handleEnterPhase1</tevid>
					<tevid>whenRequest wantToOrder -> handleOrderFromClientPhase1</tevid>
					<tevid>whenMsg ready -> serveTeaToClientPhase1</tevid>
					<tevid>whenEvent timeout -> handleTimeoutPhase1</tevid>
					<tevid>whenRequest billPlease -> handlePaymentPhase1 </tevid>
					<tevid>whenMsg cleanTable -> cleanTeatablePhase1</tevid>
	
	<comm>// WAITER GO HOME</comm>
	<sevid>State goHome</sevid> {
		<change_evid>updateResource[#"goingHome"#]</change_evid>
		<mevid>request mover -m moveTo : moveTo(home)</mevid>
		
	}
	<tevid>Transition t0 whenReply done -> restingAtHome</tevid>
	
	<comm>//-------------------------------------------- WAITER HANDLE ENTER REQUEST ----------------------------------------------------</comm>
	<sevid>State handleEnterPhase1</sevid> {
		
		onMsg(enter : enter(CLIENT_ID)){
			if [# WasCleaning == true #]{
				[# var TempTime = 0L #]
				memoCurrentTime TempTime
				[# TimeToClean = TimeToClean - (TempTime - TimeCleanBegan) #]
				println("waiter | interrupted cleaning to handle enter request")
			}
			[#ClientToConvoy = payloadArg(0)#]
			println("waiter | a client with client_id ${payloadArg(0)} asked to enter the safe tearoom...")
			println("waiter | checking if the safe tearoom has a free table ...")
			<mevid>request tearoom -m getRoomState : getRoomState(getFreeTable, arg1)</mevid>
		} //onMsg
		
	}
	<tevid>Transition t0 whenReply state -> handleEnterPhase2</tevid>
	
	<sevid>State handleEnterPhase2</sevid> {
		
		onMsg(state : state(S)){
			if [#payloadArg(0).toInt() != -1 #] { <comm>//NO free and clean table (CAN'T HAPPEN in this first prototype since there is only one client)</comm>
				[# 
					MaxWaitTime =  getMaxWaitTime()
				#]
				println("waiter | ... but since there is no free and clean teatable I ask ${payloadArg(0)} to wait a little ($MaxWaitTime)!")
				<mevid>emit wait : wait($payloadArg(0), $MaxWaitTime)</mevid>
			}
			else { <comm>// there is a free and clean table and Tearoom sent me it's ID</comm>
				[# 
					MaxWaitTime =  0L
					DestTable = payloadArg(0).toInt()
				#]
			}
			
		}
		
	}
	<tevid>Goto convoyClientToTablePhase1 if [# MaxWaitTime == 0L #] else checkIfWasCleaning</tevid>
	
	<sevid>State checkIfWasCleaning</sevid>{
		//
	}
	<tevid>Goto doATask if [# WasCleaning == false #] else cleanTeatablePhase1</tevid>
	
	<comm>//--------------------------------------  WAITER CONVOY CLIENT TO TABLE  ----------------------------------------- </comm>
	
	<sevid>State convoyClientToTablePhase1</sevid> {
		<change_evid>updateResource[#"convoyingClientToTable($DestTable,$ClientToConvoy)"#]</change_evid>
		println("waiter | reaching entrance door to convoy client $ClientToConvoy to teatable $DestTable ...")
		<mevid>request mover -m moveTo : moveTo(entrance)</mevid>
	}
	<tevid>Transition t0 whenReply done -> convoyClientToTablePhase2</tevid>
	
	<sevid>State convoyClientToTablePhase2</sevid> {
		<mevid>emit wait : wait($ClientToConvoy , $MaxWaitTime)</mevid>
		println("waiter | convoying client $ClientToConvoy to teatable $DestTable ...")
		[#var Dest =  "teatable" + DestTable.toString() #]
		<mevid>request mover -m moveTo : moveTo($Dest)</mevid>
	}
	<tevid>Transition t0 whenReply done -> convoyClientToTablePhase3</tevid>
		
	<sevid>State convoyClientToTablePhase3</sevid> {
		
		<mevid<>forward tearoom -m updateState : updateState (updateTableState, $DestTable, busy, $ClientToConvoy)</mevid>
		<mevid>emit sitPlease : sitPlease($ClientToConvoy, $DestTable )</mevid>
		<comm>//start timer to count until MaxStayTime</comm>
		<mevid>forward mastertimer -m startTimer : startTimer($DestTable, $MaxStayTime)</mevid>
		
	}
	<tevid>Goto doATask if [# WasCleaning == false #] else cleanTeatablePhase1</tevid>
	
	
<comm>//---------------------------------------WAITER CLEAN TABLE ---------------------------------------------------------</comm>
	<sevid>State cleanTeatablePhase1</sevid> {
		
		onMsg(cleanTable : cleanTable(T)) {
			<comm>//first we reach the teatable</comm>
			[#
			  Dest =  "teatable" + payloadArg(0) 
			  DestTable = payloadArg(0).toInt()
			  TableToClean = payloadArg(0).toInt()
			#]
		}
		
		<comm>//resuming cleaning if waiter was cleaning</comm>
		if[# WasCleaning == true #]{
			println("Waiter moving towards teable $TableToClean to resume cleaning")
			[#
			  Dest =  "teatable" + TableToClean
			  DestTable = TableToClean
			#]
		}
		
		
		<change_evid>updateResource[#"cleaning($DestTable)"#]</change_evid>
		<mevid>request mover -m moveTo : moveTo($Dest)</mevid>
	}
	<tevid>Transition t0 whenReply done -> cleanTeatablePhase2</tevid>
	
	<sevid>State cleanTeatablePhase2</sevid> {
		
		<comm>// then we clean the teatable</comm>
		println("waiter | cleaning the teatable ${payloadArg(0)}")
		[#
			WasCleaning = true
		#]
		memoCurrentTime TimeCleanBegan					
	}
	<tevid>Transition t1 whenTimeVar TimeToClean -> finishedClean</tevid>
				  <tevid>whenMsg ready -> serveTeaToClientPhase1</tevid>
				  <tevid>whenMsg enter -> handleEnterPhase1</tevid>
				  <tevid>whenMsg wantToOrder -> handleOrderFromClientPhase1</tevid>
				  <tevid>whenMsg billPlease -> handlePaymentPhase1</tevid>
				  
	<sevid>State finishedClean</sevid>{
		
		println("waiter | finished cleaning teatable $TableToClean")
		<comm>//update teatable state</comm>
		<mevid>forward tearoom -m updateState : updateState (updateTableState, $TableToClean, clean, ARG3)</mevid>
		[# 
			WasCleaning = false
			TimeToClean = 2000L
			TableToClean = 0
			TimeCleanBegan = 0L
		#]
	}
	<tevid>Goto doATask</tevid>


<comm>//-------------------------------------------- WAITER TAKE CLIENT's ORDER -------------------------------------------</comm>
	<sevid>State handleOrderFromClientPhase1</sevid> {
		
		onMsg(wantToOrder : wantToOrder(TEATABLE_ID)){
		
			if [# WasCleaning == true #]{
				[# var TempTime = 0L #]
				memoCurrentTime TempTime
				[# TimeToClean = TimeToClean - (TempTime - TimeCleanBegan) #]
				println("waiter | interrupted cleaning to handle order request")
			}
			<comm>//Stop timer </comm>
			<mevid>forward mastertimer -m stopTimer : stopTimer($payloadArg(0))</mevid>
			println("waiter | client at teatable ${payloadArg(0)} want to order! Reaching table ${payloadArg(0)}...")
			<comm>// reach teatable to take client order</comm>
			[#var 
				Dest =  "teatable" + payloadArg(0)
				DestTable = payloadArg(0).toInt()
			#]
			<change_evid>updateResource[#"takingOrder(${payloadArg(0)})"#]</change_evid>
			<mevid>request mover -m moveTo : moveTo($Dest)</mevid>
		}
	}
	<tevid>Transition t0 whenReply done -> handleOrderFromClientPhase2</tevid>
	
	<sevid>State handleOrderFromClientPhase2</sevid> {
		
		<mevid>emit orderPlease : orderPlease(ARG)</mevid>
	}
	<tevid>Transition t0 whenMsg tea -> handleOrderFromClientPhase3</tevid>
	
	<sevid>State handleOrderFromClientPhase3</sevid> {
		
		onMsg(tea : tea(TABLE,TEA)){
			println("waiter | client at teatable ${payloadArg(0)} ordered a ${payloadArg(1)}! Sending order to Barman...")
			<mevid>forward barman -m  order : order($payloadArg(0), $payloadArg(1))</mevid>
		}
		
	}
	<tevid>Goto cleanTeatablePhase1 if [# WasCleaning == true #] else doATask</tevid>


<comm>//------------------------------------------ WAITER SERVE CLIENT  --------------------------------------------------</comm>	
	
	<sevid>State serveTeaToClientPhase1</sevid> {
		
		onMsg(ready : ready(T,D)){
			if [# WasCleaning == true #]{
				[# var TempTime = 0L #]
				memoCurrentTime TempTime
				[# TimeToClean = TimeToClean - (TempTime - TimeCleanBegan) #]
				println("waiter | interrupted cleaning to serve")
			}
			[# 
				DestTable = payloadArg(0).toInt()
				CurDrink = payloadArg(1)
			#]
			println("waiter | order for table ${payloadArg(0)} ready! Reaching service desk...")
			<change_evid>updateResource[#"servingTea($DestTable)"#]</change_evid>				
			<mevid>request mover -m moveTo : moveTo(servicedesk)</mevid>
		}
		
	}
	<tevid>Transition t0 whenReply done -> servTeaToClientPhase2</tevid>
	
	<sevid>State servTeaToClientPhase2</sevid> {
		
			println("waiter | bringing tea to table $DestTable...")
			[#var Dest =  "teatable" + DestTable #]
			<mevid>request mover -m moveTo : moveTo($Dest)</mevid>
			
	}
	<tevid>Transition t0 whenReply done -> servTeaToClientPhase3</tevid>
	
	<sevid>State servTeaToClientPhase3</sevid> {
			delay 1000
			<mevid>emit teaServed : teaServed($DestTable, $CurDrink )</mevid>
			<comm>//start counting for consumingTime NOW</comm>
			<comm>//start timer to count until MaxStayTime</comm>
			<mevid>forward mastertimer -m resumeTimer : resumeTimer($DestTable)</mevid>
	
	}		
	<tevid>Goto cleanTeatablePhase1 if [# WasCleaning == true #] else doATask</tevid>


<comm>//-----------------------------------WAITER HANDLE PAYMENT  -------------------------------------------------------/</comm>

	<sevid>State handlePaymentPhase1</sevid>{
		
		onMsg(billPlease : billPlease(T)){
		
			if [# WasCleaning == true #]{
				[# var TempTime = 0L #]
				memoCurrentTime TempTime
				[# TimeToClean = TimeToClean - (TempTime - TimeCleanBegan) #]
				println("waiter | interrupted cleaning to handle payment request")
			}
			
			<comm>// stopping timer</comm>
			println("waiter | Client at table ${payloadArg(0)} is ready to pay. Ending timer for table ${payloadArg(0)}")
			<mevid>forward mastertimer -m endTimer : endTimer($payloadArg(0))</mevid>
			
			<comm>// reaching table</comm>
			[#
				<comm>//memorizing teatable_id for next phase</comm>
				DestTable = payloadArg(0).toInt()
				var Dest = "teatable" + payloadArg(0)
			#]
			println("waiter | Reaching table ${payloadArg(0)} ...")
			<change_evid>updateResource[#"handlePayment($DestTable)"#]</change_evid>
			<mevid>request mover -m moveTo : moveTo($Dest)</mevid>
		}
		
	}
	<tevid>Transition t0 whenReply done -> handlePaymentPhase2</tevid>
	
	<sevid>State handlePaymentPhase2</sevid> {
		println("waiter | Asking Client at table $DestTable to pay ...")
		delay 500
		<mevid>emit cardPlease : cardPlease($Price) </mevid>
		<comm>//get client_id from table_id</comm>
		<mevid>request tearoom -m getRoomState : getRoomState(getClientFromTable, $DestTable) </mevid>
	}
	<tevid>Transition t0 whenReply state -> convoyClientToExitPhase1</tevid>
	
	<sevid>State convoyClientToExitPhase1</sevid> {
		println("waiter | Asking Client at table $DestTable to pay ...")
		onMsg(state : state(C)){
			println("waiter | Convoying Client ${payloadArg(0)} to exit door ...")
			[# ClientToConvoy = payloadArg(0)#]
			<change_evid>updateResource[#"convoyingClientToExitDoor($ClientToConvoy)"#]</change_evid>
			<mevid>request mover -m moveTo : moveTo(exit)</mevid>
		}
	}
	<tevid>Transition t0 whenReply done -> convoyClientToExitPhase2</tevid>
	
	<sevid>State convoyClientToExitPhase2</sevid> {
			println("waiter | saying goodbye to client $ClientToConvoy...")
			<mevid>emit exitPlease : exitPlease($ClientToConvoy)</mevid>
			
			<comm>//updating teatable state</comm>
			<mevid>forward tearoom -m updateState : updateState(updateTableState, $DestTable, dirty, ARG)</mevid>
			
			<comm>//remember to clean the table</comm>
			<mevid>forward waiter -m cleanTable : cleanTable($DestTable)</mevid>
	}
	<tevid>Goto cleanTeatablePhase1 if [# WasCleaning == true #] else doATask</tevid>
	
	
<comm>//----------------  WAITER HANDLE SLOW CLIENT  ---------------------------------------------------------------</comm>	

	<sevid>State handleTimeoutPhase1</sevid> {
		
		onMsg(timeout : timeout(T)){
			println("waiter | Time exceeded for client at table ${payloadArg(0)}")
			println("waiter | reaching table ${payloadArg(0)}...")
			
			[#
				DestTable = payloadArg(0).toInt()
				var Dest = "teatable" + payloadArg(0)
			#]
			<change_evid>updateResource[#"handlePayment($DestTable)"#]</change_evid>
			<mevid>request mover -m moveTo : moveTo($Dest)</mevid>
		}
	}
	<tevid>Transition t0 whenReply done -> handleTimeoutPhase2</tevid>
	
	<sevid>State handleTimeoutPhase2</sevid> {
			println("waiter | communicating to client at table ${payloadArg(0)} that he has to pay and leave...")
			<mevid>emit maxTimeExceeded : maxTimeExceeded($payloadArg(0), $Price)</mevid>
						
			<comm>//get client_id from table_id</comm>
			<mevid>request tearoom -m getRoomState : getRoomState(getClientFromTable, $DestTable)</mevid>	
			
	}
	<tevid>Transition t0 whenReply state -> convoyClientToExitPhase1</tevid>	
	
}</code></pre>
			<h5>MasterTimer QAKctor</h5>
			<pre class="mytab"><code><keyw>System </keyw> mastertimer

<keyw>mqttBroker</keyw> <strs>"localhost"</strs> : <ints>1883</ints> <keyw>eventTopic</keyw> "unibo/polar" 	<comm>//mqtt.eclipse.org</comm>

<comm>//----------- WAITER-MASTERTIMER INTERACTION --------------</comm>
<keyw>Dispatch</keyw> startTimer 	: startTimer(TEATABLE_ID, MAX_TIME)	   
<keyw>Dispatch</keyw> stopTimer 	: stopTimer(TEATABLE_ID)			   
<keyw>Dispatch</keyw> resumeTimer 	: resumeTimer(TEATABLE_ID)			   
<keyw>Dispatch</keyw> endTimer 		: endTimer(TEATABLE_ID)				   
<keyw>Event</keyw> timeout 			: timeout(TEATABLE_ID)
<comm>//---------------------------------------------------------</comm>	
<comm>//----------- MASTERTIMER-SUBTIMER INTERACTION ------------</comm>
<keyw>Dispatch</keyw> startSubtimer 	: startSubtimer( MAX_TIME)	   
<keyw>Dispatch</keyw> stopSubtimer 		: stopSubtimer(ARG)			   
<keyw>Dispatch</keyw> resumeSubtimer 	: resumeSubtimer(ARG)			   
<keyw>Dispatch</keyw> endSubtimer 		: endSubtimer(ARG)				   
<keyw>Dispatch</keyw> timeoutSubtimer 	: timeoutSubtimer(TEATABLE_ID)
<comm>//---------------------------------------------------------</comm>

</code></pre>
		</br>
		<pre class="mytab"><code>Context ctxmastertimer ip [host="someip" port=8010]

<sevid>QActor mastertimer</sevid> context ctxmastertimer {
	
	<sevid>State s0 initial</sevid> {
		discardMsg Off
	}
	<tevid>Goto waitForCommand</tevid>
	
	<sevid>State waitForCommand</sevid>{
		println("mastertimer | waiting for waiter's command...")
	}
	<tevid>Transition t0 	whenMsg startTimer -> startTimer</tevid>
					<tevid>whenMsg stopTimer -> stopTimer</tevid>
					<tevid>whenMsg resumeTimer -> resumeTimer</tevid>
					<tevid>whenMsg endTimer -> endTimer</tevid>
					<tevid>whenMsg timeoutSubtimer -> handleTimeout</tevid>
	
	<sevid>State startTimer</sevid> {
		onMsg(startTimer : startTimer(TABLE, TIME)){
			println("mastertimer | starting timer for teatable ${payloadArg(0)} and timeout ${payloadArg(1)} ms")
		    [#var Teatable = payloadArg(0).toInt()#]
		    if [#Teatable == 1#]{
		    	<mevid>forward subtimer1 -m startSubtimer : startSubtimer($payloadArg(1))</mevid>
		    }
		    if [#Teatable == 2#]{
		    	<mevid>forward subtimer2 -m startSubtimer : startSubtimer($payloadArg(1))</mevid>
		    }
		}
		
	}
	<tevid>Goto waitForCommand</tevid>
	
	<sevid>State stopTimer</sevid> {
		onMsg(stopTimer : stopTimer(TABLE)) {
			
			 [#var Teatable = payloadArg(0).toInt()#]
			 println("mastertimer | stopping timer for teatable $Teatable...")
			 
		    if [#Teatable == 1#]{
		    	<mevid>forward subtimer1 -m stopSubtimer : stopSubtimer(arg)</mevid>
		    }
		    if [#Teatable == 2#]{
		    	<mevid>forward subtimer2 -m stopSubtimer : stopSubtimer(arg)</mevid>
		    }
		}
	}
	<tevid>Goto waitForCommand</tevid>
	
	<sevid>State resumeTimer</sevid> {
		onMsg(resumeTimer : resumeTimer(TABLE)) {
			 [#var Teatable = payloadArg(0).toInt()#]
			 println("mastertimer | resuming timer for teatable $Teatable...")
			 
		    if [#Teatable == 1#]{
		    	<mevid>forward subtimer1 -m resumeSubtimer : resumeSubtimer(arg)</mevid>
		    }
		    if [#Teatable == 2#]{
		    	<mevid>forward subtimer2 -m resumeSubtimer : resumeSubtimer(arg)</mevid>
		    }
		}
	}
	<tevid>Goto waitForCommand</tevid>
	
	<sevid>State endTimer</sevid> {
		onMsg(endTimer : endTimer(TABLE)) {
			 [#var Teatable = payloadArg(0).toInt()#]
			 println("mastertimer | ending timer for teatable $Teatable...")
			 
		    if [#Teatable == 1#]{
		    	<mevid>forward subtimer1 -m endSubtimer : endSubtimer(arg)</mevid>
		    }
		    if [#Teatable == 2#]{
		    	<mevid>forward subtimer2 -m endSubtimer : endSubtimer(arg)</mevid>
		    }
		}
	}
	<tevid>Goto waitForCommand</tevid>
	
	<sevid>State handleTimeout</sevid> {
		onMsg(timeoutSubtimer : timeoutSubtimer(TABLE)){
			[#var Teatable = payloadArg(0).toInt()#]
			println("mastertimer | timeout for teatable $Teatable...")
			<mevid>emit timeout : timeout($Teatable)</mevid>
		} 
	}
	<tevid>Goto waitForCommand</tevid>
	
}</code></pre>
<p>
	The subtimer actors used in the QAK above (subtimer1 and subtimer2) have a structure that can be identified by the general underlying QAKctor:
</p>
<pre class="mytab"><code><sevid>QActor subtimerN </sevid> context ctxmastertimer {
	
	[#
		val Teatable = 1
		var RemainingTime : Long = -1
		var Record : Long = -1
	#]
	
	<sevid>State s0 initial</sevid> {
		discardMsg Off
	}
	<tevid>Goto waitingForCommand</tevid>
	
	<sevid>State waitingForCommand</sevid> {
		println("subtimer | waiting for mastertimer's command...")
	}
	<tevid>Transition t0 	whenMsg startSubtimer -> startTimer</tevid>

	
	<sevid>State startTimer</sevid> {
		onMsg(startSubtimer : startSubtimer(MAX_TIME)){
			println("subtimer | starting timer for teatable $Teatable and timeout ${payloadArg(0)} ms")
			[#
				RemainingTime = payloadArg(1).toLong()
			#]
			memoCurrentTime Record
		}
	}
	<tevid>Transition t0 	whenTimeVar RemainingTime -> handleTimeout</tevid>
					<tevid>whenMsg stopSubtimer -> stopTimer</tevid>
					<tevid>whenMsg endSubtimer -> endTimer </tevid>//customer decided to not order a drink
	
	<sevid>State stopTimer</sevid> {
		println("subtimer | stopping timer for teatable $Teatable...")
		[# var previousInstant = Record#]
		memoCurrentTime Record
		[# RemainingTime = RemainingTime - (Record - previousInstant) #]
	}
	<tevid>Transition t0	whenMsg resumeTimer -> resumeTimer</tevid>
	
	<sevid>State resumeTimer</sevid> {
		println("subtimer | resuming timer for teatable $Teatable...")
		memoCurrentTime Record
	}
	<tevid>Transition t0	whenTimeVar RemainingTime -> handleTimeout</tevid>	
					<tevid>whenMsg endSubtimer -> endTimer</tevid>
					
	<sevid>State handleTimeout</sevid> {
		println("subtimer | TIMEOUT! time expired for teatable $Teatable!")
		<mevid>forward mastertimer -m timeoutSubtimer : timeoutSubtimer($Teatable)</mevid>
	}
	<tevid>Goto waitingForCommand</tevid>
		
	<sevid>State endTimer</sevid> {
		println("subtimer | removing timer for teatable $Teatable...")
	}
	<tevid>Goto waitingForCommand</tevid>
}</code></pre>
			<h5>Tearoom QAKctor</h5>
			<pre class="mytab"><code><keyw>System</keyw> tearoom
			
<keyw>Request</keyw> getRoomState : getRoomState(REQUEST, ARG1)
<keyw>Reply</keyw> state : state(STATE)	
<keyw>Dispatch</keyw> updateState : updateState (UPDATE_REQUEST, ARG1, ARG2, ARG3)

<comm>// REQUEST can be: 
// 				getNumFreeTables
//				getFreeTable
// 				getTablesState		(Not for now)
// 				getTableFromClient	[ARG1 = client_id]
// 				getClientFromTable	[ARG1 = teatable_id]
// UPDATE-REQUEST can be: 
// 				updateTableState  [ARG1 = teatable_id {1,2}, ARG2 = new_state {busy, dirty, clean}, if ARG2=busy => ARG3= client_id]
// 				updateBound		  [ARG1 = teatable_id {1,2}, ARG2 = client_id]</comm></code></pre>
		</br>
		<pre class="mytab"><code>Context ctxtearoom 			ip [host="localhost" port=8015]
Context ctxwaiter 		 	ip [host="127.0.0.1" port=8029]

ExternalQActor waiter context ctxwaiter

<sevid>QActor tearoom</sevid> context ctxtearoom {
	
	<sevid>State s0 initial</sevid> {
		
		discardMsg Off
		solve(consult("state.pl"))
		
		<change_evid>updateResource [# "teatable1(clean,no):teatable2(clean,no)"#]</change_evid>
	}
	<tevid>Goto waitingForCommand</tevid>
	
	<sevid>State waitingForCommand</sevid> {
		println("tearoom | waiting for command...")
	}
	<tevid>Transition t0	whenRequest getRoomState -> handleRequest</tevid>
					<tevid>whenMsg updateState -> handleUpdate</tevid>
	
	<sevid>State handleRequest</sevid> {
		
		<comm>// REQUEST: getFreeTable</comm>
		onMsg(getRoomState : getRoomState(getFreeTable, A)){
			[# var Table = 0 #]
		
			solve(teatable(T, clean))	
			ifSolved { [# Table = getCurSol("T").toString().toInt() #] 
				println("tearoom | table $Table is free")
			}
			<mevid>replyTo getRoomState with state : state($Table)</mevid>
			
		}
		
		<comm>// REQUEST: getNumFreeTables</comm>
		onMsg(getRoomState : getRoomState(getNumFreeTables, A)){
			[# var Num = 0 #]
		
			solve(numfreetables(N))	
			ifSolved { [# Num = getCurSol("N").toString().toInt() #] }
			println("tearoom | number of free table: $Num")
			<mevid>replyTo getRoomState with state : state($Num)</mevid>
			
		}
		
		<comm>// REQUEST: getTableFromClient</comm>
		onMsg(getRoomState : getRoomState(getTableFromClient, A)){
			
			[# 
				var Client_id = payloadArg(1)
				var ID = 0			  
			#]
			solve(bound(N,$Client_id))	
			ifSolved { [# ID = getCurSol("N").toString().toInt() #] 
				println("tearoom | client $Client_id is at table $ID")
			}
			<mevid>replyTo getRoomState with state : state($ID)</mevid>
			
		}
		
		<comm>// REQUEST: getClientFromTable</comm>
		onMsg(getRoomState : getRoomState(getClientFromTable, A)){
			println("tearoom | INSIDE GET_CLIENT_FORM_TABLE")
			[# 
				var C = "no"
				var ID = payloadArg(1).toInt()		  
			#]
			solve(bound($ID,N))	
			ifSolved { [# C = getCurSol("N").toString() #] }
			println("tearoom | table $ID is used by client $C")
			<mevid>replyTo getRoomState with state : state($C)</mevid>
			
		}
	}
	<tevid>Goto waitingForCommand</tevid>
	
	<sevid>State handleUpdate</sevid> {
		
		//println("tearoom | INSIDE HANDLE_UPDATE")
		printCurrentMessage
		
		<comm>// UPDATE-REQUEST: updateTableState CLEAN</comm>
		onMsg(updateState : updateState(updateTableState, ID, clean, A )){
			
			[# var T =  payloadArg(1).toInt() #]
			solve(setCleanTable($T))
			println("tearoom | update State: table $T is now clean")
			
		}
		
		<comm>// UPDATE-REQUEST: updateTableState DIRTY</comm>
		onMsg(updateState : updateState(updateTableState, ID, dirty, A )){
			
			[# 
				var T =  payloadArg(1).toInt() 
				var C = "NO"
			#]
			solve(setDirtyTable($T))
			solve(assign($T,$C))
			println("tearoom | update State: table $T is now dirty")
			
		}
		
		<comm>// UPDATE-REQUEST: updateTableState BUSY</comm>
		onMsg(updateState : updateState(updateTableState, ID, busy, A )){
			
			[# 
				var T =  payloadArg(1).toInt() 
				var C = payloadArg(3)
			#]
			solve(setBusyTable($T))
			solve(assign($T,$C))
			println("tearoom | update State: table $T is now busy and assigned to client $C")
			
		}
	}
	<tchange_evid>Goto updateCoapResource</tchange_evid>
	
	<schange_evid>State updateCoapResource</schange_evid> {
		[#
			var state1 : String = ""
			var state2 : String = ""
			var bound1 : String = ""
			var bound2 : String = ""
		#]
		solve(teatable(1,N))
		ifSolved { [# state1 = getCurSol("N").toString() #] }
		solve(teatable(2,N))
		ifSolved { [# state2 = getCurSol("N").toString() #] }
		solve(bound(1,N))
		ifSolved { [# bound1 = getCurSol("N").toString() #] }
		solve(bound(2,N))
		ifSolved { [# bound2 = getCurSol("N").toString() #] }
		[# var resource = "teatable1($state1,$bound1):teatable2($state2,$bound2)"#]
		<change_evid>updateResource[# "$resource" #]</change_evid>
	}
	<tchange_evid>Goto waitingForCommand</tchange_evid>
}</code></pre>
			
		</li>
		</li>
		<li><h4>Abstraction gap:</h4>
			<h5>Application</h5>
			<p>The considerations made in the last sprint (<a href="https://htmlpreview.github.io/?https://github.com/gitemar/Martini_Drudi_Safe_Tearoom/blob/master/week_2_step_1/userDocs/Documento_Martini_Drudi.html">Sprint 1</a>) are still valid in this second Sprint
			<h5>Web-GUI: Client and ManagerGUI</h5>
			<p>As for what concernes the user interface, the usage of Spring Web ( <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html">Spring Web MVC</a> ) reduces the abstraction gap. In fact, the Spring Framework, with the help of Spring Boot ( <a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/iss2020LabBo/master/webspring.intro/userDocs/LabSpringIntro.html">Spring Boot</a> ) provides a way to quickly develop applications without concerning about the lower part of it: in the web case, Spring Web creates and manages a standalone server (Tomcat) and relative beans, all sone automatically, so that the developer can concentrate on the business logic of the web-app.</p>
		</li>
		<li><h4>Functional TestPlan:</h4>
			<p>The considerations made in the last sprint (<a href="https://htmlpreview.github.io/?https://github.com/gitemar/Martini_Drudi_Safe_Tearoom/blob/master/week_2_step_1/userDocs/Documento_Martini_Drudi.html">Sprint 1</a>) are still valid in this second Sprint.
			
		</li>
		<li><h4>Product backlog:</h4>
			<p>The goal of this second Sprint is to develop the Manager Web-GUI and to implement the necessary changes to the Waiter. The team will also develop the Mastertimer and Subtimers components that will take the place of the old Timer actor.
		</li>
	</ol>
</div>


 <!--------------------------------------------------------------------------------------------------------------------------------->

<table id="authors" border="1" align="center">
<tr>
<td style="width:50%">
<center>By Elena Martini ~ email: elena.martini6@studio.unibo.it</center> 
</td>
<td style="width:50%">
<center>By Elisa Drudi ~ email: elisa.drudi4@studio.unibo.it </center>
</td>
</tr>
<!-- ---------------->
<tr>
<td style="width:50%">
<center><img src="./img/elena.jpg" alt="mbot" width="100%"></center>
</td>
<td style="width:50%">
<center><img src="./img/elisa.jpg" alt="mbot" width="100%"></center>
</td>
</tr>
</table>  
</body>
</html>

<html><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><meta name="Robots" content="NOINDEX " /></head><body></body>
                <script type="text/javascript">
                 var gearPage = document.getElementById('GearPage');
                 if(null != gearPage)
                 {
                     gearPage.parentNode.removeChild(gearPage);
                     document.title = "Error";
                 }
                 </script>
</html>